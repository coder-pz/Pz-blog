# 探索原理与实现

## 一、响应式原理

### 1.1 什么是响应式

+ 在一些值变化时，一些函数或者语句做出来一些反应或响应，就叫做响应式

```js
// let m = 100

// // 一段代码
// console.log(m)
// console.log(m * 2)
// console.log(m ** 2)
// console.log("Hello World")

// m = 200// m变化上边代码重新执行这就叫做响应式

// 对象的响应式
const obj = {
  name: "why",
  age: 18
}

const newName = obj.name
console.log("你好啊, 李银河")
console.log("Hello World")
console.log(obj.name) // 100行
obj.name = "kobe"//obj中的name 变化上边代码重新执行这就叫做对象的响应式


```

### 1.2 Vue3响应式原理（Proxy）

#### 1.2.1 使用函数 1.0手动版本(只针对指定变量)

```js
/**
 * 响应式函数 针对某一个指定变量手动调用
 */


// 封装一个响应式的函数
let reactiveFns = []//装载需要响应式调用的函数
function watchFn(fn) {//创建响应式函数
  reactiveFns.push(fn)
}

// 对象的响应式
const obj = {
  name: "why",
  age: 18
}

watchFn(function() {//将需要响应式调用的函数传入
  const newName = obj.name
  console.log("你好啊, 李银河")
  console.log("Hello World")
  console.log(obj.name) // 100行
})

watchFn(function() {//将需要响应式调用的函数传入
  console.log(obj.name, "demo function -------")
})

function bar() {
  console.log("普通的其他函数")
  console.log("这个函数不需要有任何响应式")
}

obj.name = "kobe"//当obj.name变化时候 循环调用 需要响应式的函数
reactiveFns.forEach(fn => {
  fn()
})

```

#### 1.2.2 使用 类 函数 2.0手动版本(只针对指定变量)

```js
class Depend {
  constructor() {//每次new一个新的数据
    this.reactiveFns = []
  }

  addDepend(reactiveFn) {//将需要响应的函数传入
    this.reactiveFns.push(reactiveFn)
  }

  notify() {//调用需要响应的函数
    this.reactiveFns.forEach(fn => {
      fn()
    })
  }
}

// 封装一个响应式的函数
const depend = new Depend()
function watchFn(fn) {
  depend.addDepend(fn)
}

// 对象的响应式
const obj = {
  name: "why", // depend对象
  age: 18 // depend对象
}

watchFn(function() {
  const newName = obj.name
  console.log("你好啊, 李银河")
  console.log("Hello World")
  console.log(obj.name) // 100行
})

watchFn(function() {
  console.log(obj.name, "demo function -------")
})

obj.name = "kobe"
depend.notify()

```

#### 1.2.3 使用Proxy监听 3.0自动版本(只针对指定变量)

+ 响应式监听
  + **Vue2** 使用的是 **Object.defineProperty()**
  + **Vue3** 使用的是 **Proxy()**

```js
class Depend {
  constructor() {//每次new一个新的数据
    this.reactiveFns = []
  }

  addDepend(reactiveFn) {//将需要响应的函数传入
    this.reactiveFns.push(reactiveFn)
  }

  notify() {//调用需要响应的函数
    this.reactiveFns.forEach(fn => {
      fn()
    })
  }
}

// 封装一个响应式的函数
const depend = new Depend()
function watchFn(fn) {
  depend.addDepend(fn)
}

// 对象的响应式
const obj = {
  name: "why", // depend对象
  age: 18 // depend对象
}

// 监听对象的属性变量: Proxy(vue3)/Object.defineProperty(vue2)
const objProxy = new Proxy(obj, {
  get: function(target, key, receiver) {
    return Reflect.get(target, key, receiver)
  },
  set: function(target, key, newValue, receiver) {//监听值变化调用响应式方法
    Reflect.set(target, key, newValue, receiver)
    depend.notify()
  }
})

watchFn(function() {
  const newName = objProxy.name
  console.log("你好啊, 李银河")
  console.log("Hello World")
  console.log(objProxy.name) // 100行
})

watchFn(function() {
  console.log(objProxy.name, "demo function -------")
})

watchFn(function() {
  console.log(objProxy.age, "age 发生变化是需要执行的----1")
})

watchFn(function() {
  console.log(objProxy.age, "age 发生变化是需要执行的----2")
})

objProxy.name = "kobe"
objProxy.name = "james"
objProxy.name = "curry"

objProxy.age = 100

```



#### 1.2.4 使用map与weekMap 绑定指定对象的响应式函数 4.0版本

```js
class Depend {
  constructor() {
    this.reactiveFns = []
  }

  addDepend(reactiveFn) {
    this.reactiveFns.push(reactiveFn)
  }

  notify() {
    this.reactiveFns.forEach(fn => {
      fn()
    })
  }
}

// 封装一个响应式的函数
const depend = new Depend()
function watchFn(fn) {
  depend.addDepend(fn)
}

// 封装一个获取指定key的depend函数
const targetMap = new WeakMap()
function getDepend(target, key) {
  // 根据target对象获取map的过程
  let map = targetMap.get(target)
  if (!map) {//第一次没有target对应的值则创建一个
    map = new Map()
    targetMap.set(target, map)
  }

  // 根据key获取depend对象
  let depend = map.get(key)
  if (!depend) {//第一次map中没有key对应的值则创建一个
    depend = new Depend()
    map.set(key, depend)
  }
  return depend
}

// 对象的响应式
const obj = {
  name: "why", // depend对象
  age: 18 // depend对象
}

// 监听对象的属性变量: Proxy(vue3)/Object.defineProperty(vue2)
const objProxy = new Proxy(obj, {
  get: function(target, key, receiver) {
    return Reflect.get(target, key, receiver)
  },
  set: function(target, key, newValue, receiver) {
    Reflect.set(target, key, newValue, receiver)
    // depend.notify()
    const depend = getDepend(target, key)//获取到指定key的depend类
    depend.notify()
  }
})

watchFn(function() {
  const newName = objProxy.name
  console.log("你好啊, 李银河")
  console.log("Hello World")
  console.log(objProxy.name) // 100行
})

watchFn(function() {
  console.log(objProxy.name, "demo function -------")
})

watchFn(function() {
  console.log(objProxy.age, "age 发生变化是需要执行的----1")
})

watchFn(function() {
  console.log(objProxy.age, "age 发生变化是需要执行的----2")
})

objProxy.name = "kobe"
objProxy.name = "james"
objProxy.name = "curry"

objProxy.age = 100


const info = {
  name: "kobe",
  address: "广州市"
}

watchFn(function() {
  console.log(info.address, "监听address变化+++++++++1")
})

watchFn(function() {
  console.log(info.address, "监听address变化+++++++++2")
})

// obj对象
// name: depend
// age: depend
// const objMap = new Map()
// objMap.set("name", "nameDepend")
// objMap.set("age", "ageDepend")

// // info对象
// // address: depend
// // name: depend
// const infoMap = new Map()
// infoMap.set("address", "addressDepend")


// const targetMap = new WeakMap()
// targetMap.set(obj, objMap)
// targetMap.set(info, infoMap)

// // obj.name
// const depend = targetMap.get(obj).get("name")
// depend.notify()

```

#### 1.2.5 5.0版本响应式针对对象中的key绑定

```js
class Depend {
  constructor() {
    this.reactiveFns = [];
  }

  addDepend(reactiveFn) {
    this.reactiveFns.push(reactiveFn);
  }

  notify() {
    console.log(this.reactiveFns);
    this.reactiveFns.forEach((fn) => {
      fn();
    });
  }
}

// 封装一个响应式的函数
let activeReactiveFn = null;
function watchFn(fn) {
  activeReactiveFn = fn;
  fn();
  activeReactiveFn = null;
}

// 封装一个获取指定key的depend函数
const targetMap = new WeakMap();
function getDepend(target, key) {
  // 根据target对象获取map的过程
  let map = targetMap.get(target);
  if (!map) {
    //第一次没有target对应的值则创建一个
    map = new Map();
    targetMap.set(target, map);
  }

  // 根据key获取depend对象
  let depend = map.get(key);
  if (!depend) {
    //第一次map中没有key对应的值则创建一个
    depend = new Depend();
    map.set(key, depend);
  }
  return depend;
}

// 对象的响应式
const obj = {
  name: "why", // depend对象
  age: 18, // depend对象
};

// 监听对象的属性变量: Proxy(vue3)/Object.defineProperty(vue2)
const objProxy = new Proxy(obj, {
  get: function (target, key, receiver) {
    // 根据target.key获取对应的depend
    const depend = getDepend(target, key);
    // 给depend对象中添加响应函数
    depend.addDepend(activeReactiveFn); //第一次初始化会调用所有函数并且走这里

    return Reflect.get(target, key, receiver);
  },
  set: function (target, key, newValue, receiver) {
    Reflect.set(target, key, newValue, receiver);
    // depend.notify()
    const depend = getDepend(target, key); //获取到指定key的depend类
    depend.notify();
  },
});

watchFn(function () {
  console.log("-----第一个name函数开始------");
  console.log("你好啊, 李银河");
  console.log("Hello World");
  console.log(objProxy.name); // 100行
  console.log("-----第一个name函数结束------");
});

watchFn(function () {
  console.log(objProxy.name, "demo function -------");
});

watchFn(function () {
  console.log(objProxy.age, "age 发生变化是需要执行的----1");
});

watchFn(function () {
  console.log(objProxy.age, "age 发生变化是需要执行的----2");
});

watchFn(function () {
  console.log(objProxy.name, "新函数");
  console.log(objProxy.age, "新函数");
});

console.log("------------------------------改变obj的name值");

objProxy.name = "kobe";
// objProxy.name = "james"

// objProxy.age = 20
// objProxy.age = 30

```

#### 1.2.6 终版 6.0 版本对象的响应式操作 (reactive)

```js
// 保存当前需要收集的响应式函数
let activeReactiveFn = null;

/**
 * Depend优化:
 *  1> depend方法
 *  2> 使用Set来保存依赖函数, 而不是数组[]
 */

class Depend {
  constructor() {
    this.reactiveFns = new Set(); //避免重复
  }

  // addDepend(reactiveFn) {
  //   this.reactiveFns.add(reactiveFn)
  // }

  depend() {
    if (activeReactiveFn) {
      this.reactiveFns.add(activeReactiveFn);
    }
  }

  notify() {
    this.reactiveFns.forEach((fn) => {
      fn();
    });
  }
}

// 封装一个响应式的函数
function watchFn(fn) {
  activeReactiveFn = fn;
  fn();
  activeReactiveFn = null;
}

// 封装一个获取depend函数
const targetMap = new WeakMap();
function getDepend(target, key) {
  // 根据target对象获取map的过程
  let map = targetMap.get(target);
  if (!map) {
    map = new Map();
    targetMap.set(target, map);
  }

  // 根据key获取depend对象
  let depend = map.get(key);
  if (!depend) {
    depend = new Depend();
    map.set(key, depend);
  }
  return depend;
}

function reactive(obj) {
  return new Proxy(obj, {
    get: function (target, key, receiver) {
      // 根据target.key获取对应的depend
      const depend = getDepend(target, key);
      // 给depend对象中添加响应函数
      // depend.addDepend(activeReactiveFn)
      depend.depend();

      return Reflect.get(target, key, receiver);
    },
    set: function (target, key, newValue, receiver) {
      Reflect.set(target, key, newValue, receiver);
      // depend.notify()
      const depend = getDepend(target, key);
      depend.notify();
    },
  });
}

// 监听对象的属性变量: Proxy(vue3)/Object.defineProperty(vue2)
const objProxy = reactive({
  name: "why", // depend对象
  age: 18, // depend对象
});

const infoProxy = reactive({
  address: "广州市",
  height: 1.88,
});

watchFn(() => {
  console.log(infoProxy.address);
});

infoProxy.address = "北京市";

const foo = reactive({
  name: "foo",
});

watchFn(() => {
  console.log(foo.name);
});

foo.name = "bar";

```

### 1.3 Vue2响应式原理（Object.defineProperty）



```js
// 保存当前需要收集的响应式函数
let activeReactiveFn = null

/**
 * Depend优化:
 *  1> depend方法
 *  2> 使用Set来保存依赖函数, 而不是数组[]
 */

class Depend {
  constructor() {
    this.reactiveFns = new Set()
  }

  // addDepend(reactiveFn) {
  //   this.reactiveFns.add(reactiveFn)
  // }

  depend() {
    if (activeReactiveFn) {
      this.reactiveFns.add(activeReactiveFn)
    }
  }

  notify() {
    this.reactiveFns.forEach(fn => {
      fn()
    })
  }
}

// 封装一个响应式的函数
function watchFn(fn) {
  activeReactiveFn = fn
  fn()
  activeReactiveFn = null
}

// 封装一个获取depend函数
const targetMap = new WeakMap()
function getDepend(target, key) {
  // 根据target对象获取map的过程
  let map = targetMap.get(target)
  if (!map) {
    map = new Map()
    targetMap.set(target, map)
  }

  // 根据key获取depend对象
  let depend = map.get(key)
  if (!depend) {
    depend = new Depend()
    map.set(key, depend)
  }
  return depend
}

function reactive(obj) {
  // {name: "why", age: 18}
  // ES6之前, 使用Object.defineProperty
  Object.keys(obj).forEach(key => {
    let value = obj[key]
    Object.defineProperty(obj, key, {
      get: function() {
        const depend = getDepend(obj, key)
        depend.depend()
        return value
      },
      set: function(newValue) {
        value = newValue
        const depend = getDepend(obj, key)
        depend.notify()
      }
    })
  })
  return obj
}

// 监听对象的属性变量: Proxy(vue3)/Object.defineProperty(vue2)
const objProxy = reactive({
  name: "why", // depend对象
  age: 18 // depend对象
})

const infoProxy = reactive({
  address: "广州市",
  height: 1.88
})

watchFn(() => {
  console.log(infoProxy.address)
})

infoProxy.address = "北京市"

const foo = reactive({
  name: "foo"
})

watchFn(() => {
  console.log(foo.name)
})

foo.name = "bar"
foo.name = "hhh"

```



## 二、Promise

### 2.1 promise 三个状态

+ 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝
  + 当执行executor中的代码时，处于该状态
+ 已兑现（fulfilled）: 意味着操作成功完成；
  + 执行了resolve时，处于该状态
+ 已拒绝（rejected）: 意味着操作失败
  + 执行了reject时，处于该状态

>  Promise状态一旦确定下来, 那么就不能再进入其他状态



```js
// 注意: Promise状态一旦确定下来, 那么就是不可更改的(锁定)
new Promise((resolve, reject) => {
  // pending状态: 待定/悬而未决的
  console.log("--------")
  reject() // 处于rejected状态(已拒绝状态)
  resolve() // 处于fulfilled状态(已敲定/兑现状态)
  console.log("++++++++++++")
}).then(res => {
  console.log("res:", res)
}, err => {
  console.log("err:", err)
})

```

### 2.2 promise resolve的参数三种形式

+  普通的值或者对象  pending(等待) -> fulfilled(完成)
+  传入一个promise
   + 如果传入一个promise 那么当前 promise 的状态将会移交给传入的 promise
+  传入一个对象, 并且这个对象有实现then方法(并且这个对象是实现了thenable接口) 那么也会执行该then方法, 并且由该then方法决定后续状态

> "thenable"是定义`then`方法的对象或函数。

**1、传入promise**

```js
const newPromise = new Promise((resolve, reject) => {
  // resolve("aaaaaa")
  reject("err message")
})

new Promise((resolve, reject) => {
  // pending -> fulfilled
  resolve(newPromise)//将状态移交给传入的promise
}).then(res => {
  console.log("res:", res)
}, err => {
  console.log("err:", err)
})
```

**2、传入一个对象，并且这个对象有then方法**

```js
// 2.传入一个对象, 这个兑现有then方法
new Promise((resolve, reject) => {
  // pending -> fulfilled
  const obj = {
    then: function (resolve, reject) {
      // resolve("resolve message")
      reject("reject message");
    },
  };
  resolve(obj);
}).then(
  (res) => {
    console.log("res:", res);
  },
  (err) => {
    console.log("err:", err);//err: reject message
  }
);

```

### 2.3 Promise的对象方法与类方法



#### 2.3.1 对象方法与类方法的区别



类方法：

+ Promise.all()
+ Promise.race()
+ Promise.resolve()
+ Promise.reject()

对象方法:

+ Promise.prototype.then()
+ Promise.prototype.catch()

> 类方法是在Promise类上的静态方法
>
> 而对象方法是在Promise.prototype上定义的
>
> **Object.getOwnPropertyDescriptors(Promise.prototype)** 查看对象方法

```js
const promise = new Promise()
promise.then()//对象方法通过创建对象访问
Promise.all()//类方法直接通过类就可以访问
```

#### 2.3.2 .then 方法

##### thenable

+ `thenable` 是定义`then`方法的对象或函数。

> then 方法中有两个参数 第一个是resolve的返回值，一个是reject的返回值

```js
const promise = new Promise((resolve, reject) => {
  //resolve("hahaha")
   reject(666)
})
promise.then(res => {
  console.log("res1:", res)//hahaha
},err=>{
   console.log("err1:", err)//666
})

```



+ 同一个Promise可以被多次调用then方法
+ 当我们的resolve方法被回调时, 所有的then方法传入的回调函数都会被调用

```js
const promise = new Promise((resolve, reject) => {
  resolve("hahaha")
})
promise.then(res => {
  console.log("res1:", res)//hahaha
})

promise.then(res => {
  console.log("res2:", res)//hahaha
})

promise.then(res => {
  console.log("res3:", res)//hahaha
})

```

+ then方法传入的 "回调函数" 可以有返回值
  + then方法本身也是有返回值的, 它的返回值是Promise

```js
const promise = new Promise((resolve, reject) => {
  resolve("hahaha")
})
promise
  .then((res) => {
    return "aaaaaa";
  })
  .then((res) => {
    console.log("res:", res); //aaaaaa
    return "bbbbbb";
  })
  .then((res) => {
    console.log("res:", res); //bbbbbb
  });
```

+ 返回一个 promise  
  + promise 的状态将会移交给的 promise

```js
promise
  .then((res) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve(111111);
      }, 3000);
    });
  })
  .then((res) => {
    console.log("res:", res); ///111111
  });
```

+ 如果返回的是一个对象, 并且该对象实现了thenable
  + "thenable"是定义`then`方法的对象或函数。
+ promise函数返回时自己调用了一下 `then`函数

```js
promise
  .then((res) => {
    return {
      then: function (resolve, reject) {
        resolve(222222);
      },
    };
  })
  .then((res) => {
    console.log("res:", res); //222222
  });

```



#### 2.3.3 catch 方法

1. 当executor抛出异常时, 会调用错误(拒绝)捕获的回调函数的

```js
const promise = new Promise((resolve, reject) => {
   reject("rejected status")
  // throw new Error("rejected status")
});
//第一个参数为resolve返回值 第二个reject返回值 (也可以捕获异常thorw)
promise.then(undefined, err => {
  console.log("err:", err)//rejected status
})
```

2. 通过catch方法来传入错误(拒绝)捕获的回调函数

```js
const promise = new Promise((resolve, reject) => {
   resolve();
});
promise.catch((err) => {
  console.log("err:", err);
});
promise
  .then((res) => {
    return new Promise((resolve, reject) => {
      //在then中也可以报异常和调用reject
      reject("then rejected status");
    });
    // throw new Error("error message");
  })
  .catch((err) => {
    console.log("err:", err); //then rejected status
  });

```

3. 拒绝捕获的问题在`then` 中

```js
const promise = new Promise((resolve, reject) => {
  // resolve();
  reject("rejected status");
  // throw new Error("rejected status")
});

promise.then(
  (res) => {},
  (err) => {
    console.log("err:", err); //err: rejected status
  }
);
```

```js
const promise = new Promise((resolve, reject) => {
  reject("111111");
  // resolve()
});

promise
  .then((res) => {})
  .then((res) => {
    throw new Error("then error message");
  })
  .catch((err) => {
    console.log("err:", err); //111111因为之前有错误所以捕获到了，不然输出then error message
  });

promise.catch((err) => {});
```

4. catch方法的返回值与链式

```js
const promise = new Promise((resolve, reject) => {
  reject("111111");
});

promise
  .then((res) => {
    console.log("res:", res);
  })
  .catch((err) => {
    console.log("err:", err); //111111
    return "catch return value";
  })
  .then((res) => {
    console.log("res result:", res); //catch return value
  })
  .catch((err) => {
    console.log("err result:", err);
  });

```

#### 2.3.4 finally

+ 一定会执行，完成结束

```js
const promise = new Promise((resolve, reject) => {
  // resolve("resolve message")
  reject("reject message");
});

promise
  .then((res) => {
    console.log("res:", res); //undefined
  })
  .catch((err) => {
    console.log("err:", err); //reject message
  })
  .finally(() => {
    console.log("finally code execute");
  });

```

#### 2.3.5  Promise.resolve 返回值

```js
// 转成Promise对象
function foo() {
  const obj = { name: "why" };
  return new Promise((resolve) => {
    resolve(obj);
  });
}

foo().then((res) => {
  console.log("res:", res); // { name: "why" }
});

// 类方法Promise.resolve
// 1.普通的值
const promise = Promise.resolve({ name: "why" });
// 相当于
const promise2 = new Promise((resolve, reject) => {
  resolve({ name: "why" });
});

// 2.传入Promise
const promise = Promise.resolve(
  new Promise((resolve, reject) => {
    resolve("11111");
  })
);

promise.then((res) => {
  console.log("res:", res); //11111
});

// 3.传入thenable对象

```

#### 2.3.6  Promise.reject 

```js
// const promise = Promise.reject("rejected message")
// 相当于
// const promise2 = new Promsie((resolve, reject) => {
//   reject("rejected message")
// })

// 注意: 无论传入什么值都是一样的
const promise = Promise.reject(new Promise(() => {}));

promise
  .then((res) => {
    console.log("res:", res);
  })
  .catch((err) => {
    console.log("err:", err); // Promise { <pending> }
  });

```

#### 2.3.7  Promise.all

+ **all** 可以将多个**promise**放在一起等待返回
  + **all** 本身也是一个promise
+ all中的多个**promise**如果有一个能变成了**rejected**状态，那么 **all** 整个**promise** 也会进入 **rejected** 状态

```js
// 创建多个Promise
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(11111);
  }, 1000);
});

const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(22222);
  }, 2000);
});

const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(33333);
  }, 3000);
});

// 需求: 所有的Promise都变成fulfilled时, 再拿到结果
// 意外: 在拿到所有结果之前, 有一个promise变成了rejected, 那么整个promise是rejected
Promise.all([p2, p1, p3, "aaaa"])
  .then((res) => {
    console.log(res);
  })
  .catch((err) => {
    console.log("err:", err); ///22222
  });

```

#### 2.3.8 Promise.allSettled

+ **allSettled** 解决 **all** 的一个中断全部中断
  + 但是并没有 **catch** 捕获 ，都在 then 中返回，但返回值中有状态
+ 会返回状态和当前的返回值

```js
// 创建多个Promise
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(11111)
  }, 1000);
})

const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(22222)
  }, 2000);
})

const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(33333)
  }, 3000);
})

// allSettled
Promise.allSettled([p1, p2, p3]).then(res => {
  console.log(res)
}).catch(err => {
  console.log(err)
})
/**
*[
  { status: 'fulfilled', value: 11111 },
  { status: 'rejected', reason: 22222 },//会返回状态和当前的返回值
  { status: 'fulfilled', value: 33333 }
]
*/
```

#### 2.3.9 Promise.race

+ 只要数组中有 `resolve` 或者 `reject` 其中一个返回，直接结束

```js
// 创建多个Promise
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(11111);
  }, 3000);
});

const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(22222); //第一个加载完成返回
    // resolve(11111);
  }, 500);
});

const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(33333);
  }, 1000);
});

// race: 竞技/竞赛
// 只要有一个Promise变成fulfilled状态, 那么就结束
// 意外:
Promise.race([p1, p2, p3])
  .then((res) => {
    console.log("res:", res); //22222
  })
  .catch((err) => {
    console.log("err:", err);
  });

```

#### 2.3.10 Promise.any

+ 多个捕获，只接收 **resolve** 返回值，并且有一个结束就直接回调 ，如果所有的都是 **reject** ，那么最后都执行完会进入 **catch** 返回一个数组，装载着多个 **promise** 的 **reject** 值

```js
// 创建多个Promise
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    // resolve(11111)
    reject(1111);
  }, 1000);
});

const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(22222);
  }, 500);
});

const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    // resolve(33333)
    reject(3333);
  }, 3000);
});

// any方法
Promise.any([p1, p2, p3])
  .then((res) => {
    console.log("res:", res); //1111
  })
  .catch((err) => {
    console.log("err:", err.errors); //[2222, 1111, 3333]
  });

```



### 2.4 实现 promise

#### 2.4.1 手写 promise 结构 (constructor实现)

**需求：**

1. 实现 promise constructor 根据状态返回回调函数

**思路：** 

1. 因为 promise 有状态所以先定义状态常量，并且在执行中判断当前什么状态。
2. 定义 `resolve` 与 `reject` 函数，并在调用 `Promise` 时候传入参数。

```js
// ES6 ES2015
// https://promisesaplus.com/
// 状态
const PROMISE_STATUS_PENDING = "pending"; //加载中
const PROMISE_STATUS_FULFILLED = "fulfilled"; //操作成功
const PROMISE_STATUS_REJECTED = "rejected"; //操作失败

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //判断当前状态
        this.status = PROMISE_STATUS_FULFILLED; //设置当前状态
        this.value = value; //设置正确返回值
        console.log("resolve被调用");
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //判断当前状态
        this.status = PROMISE_STATUS_REJECTED; //设置当前状态
        this.reason = reason; //设置错误返回值
        console.log("reject被调用");
      }
    };

    executor(resolve, reject);
  }
}

const promise = new PZPromise((resolve, reject) => {
  console.log("状态pending");
  resolve(1111);
  reject(2222);
});

```



#### 2.4.2 手写 then 方法

**需求：**

1. 实现 `then` 方法

**思路**

1. 在类中定义一个 `then` 方法，并在方法中转入两个参数方法 `onFulfilled` fulfilled 正确返回 与 `onRejected` rejected 失败返回，在将参数方法赋值给 class 中的值。
2. 执行构造函数 constructor 顺序时，会先执行，但这时 `.then` 还没有执行，所以需要使用 `queueMicrotask` 函数将部分代码创建一个微任务队列中，从而做到先执行 `.then` 在将响应值返回出去。

**缺点**

1. 不可以使用多个 `.then` 。
2. 不可以链式调用。

```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        this.status = PROMISE_STATUS_FULFILLED;
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          this.value = value;
          this.onFulfilled(this.value); //调用正确返回值
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        this.status = PROMISE_STATUS_REJECTED;
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          this.reason = reason;
          this.onRejected(this.reason); //调用错误返回值
        });
      }
    };

    executor(resolve, reject);
  }

  then(onFulfilled, onRejected) {
    this.onFulfilled = onFulfilled;
    this.onRejected = onRejected;
  }
}

const promise = new PZPromise((resolve, reject) => {
  console.log("状态pending");
  // reject(2222)
  resolve(1111);
});

// 调用then方法
promise
  .then(
    (res) => {
      console.log("res1:", res);
      return 1111;
    },
    (err) => {
      console.log("err:", err);
    }
  )
 
//不可以多个then调用
 promise.then(res => {
   console.log("res2:", res)
 }, err => {
   console.log("err2:", err)
 }) .then((res) => {
    //不可以链式调用
    console.log("res3:", res);
  });

```



#### 2.4.3 手写 then 方法优化 1.0

**需求：**

1. 实现 `then` 的多次调用
2. 在确定 `Promise` 状态后直接调用 `.then`

**思路**

1. 在 `then` 方法中将传入的 `onFulfilled` 与 `onRejected` 放到指定数组中，在 构造函数 constructor 对应状态的  `queueMicrotask` 微任务中遍历执行
2. 在 `then` 方法中 判断 状态是否已经结束，如果已经结束那么直接调用 `then` 传入的方法，不走 constructor

**缺点**

1. 不可以链式调用。

```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    executor(resolve, reject);
  }

  then(onFulfilled, onRejected) {
    // 1.如果在then调用的时候, 状态已经确定下来直接执行
    if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
      onFulfilled(this.value);
    }
    if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
      onRejected(this.reason);
    }

    // 2.当前状态等于pedding时候将成功回调和失败的回调放到数组中
    if (this.status === PROMISE_STATUS_PENDING) {
      this.onFulfilledFns.push(onFulfilled);
      this.onRejectedFns.push(onRejected);
    }
  }
}

const promise = new PZPromise((resolve, reject) => {
  console.log("状态pending");
  resolve(1111); // resolved/fulfilled
  reject(2222);
});

// 调用then方法多次调用
promise.then(
  (res) => {
    console.log("res1:", res);
  },
  (err) => {
    console.log("err:", err);
  }
);

promise.then(
  (res) => {
    console.log("res2:", res);
  },
  (err) => {
    console.log("err2:", err);
  }
);

// const promise = new Promise((resolve, reject) => {
//   resolve("aaaaa")
// })

// 在确定Promise状态之后, 再次调用then
setTimeout(() => {
  promise.then(
    (res) => {
      console.log("res3:", res);
    },
    (err) => {
      console.log("err3:", err);
    }
  );
}, 1000);

```

#### 2.4.4 手写 then 方法 优化 2.0

**需求：**

1. 实现 `then` 的链式调用

**思路**

1. 原生 `Promise` then 方法中返回的是一个 `Promise` 对象所以可以链式调用,那么就 `then` 放大中返回 `Promise` 来实现 链式调用
2. 并在 then 中 try catch 捕获异常，区分返回 `resolve` 还是 `reject`



```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

// 工具函数
// 返回resolve || reject
function execFunctionWithCatchError(execFn, value, resolve, reject) {
  try {
    const result = execFn(value);
    resolve(result);
  } catch (err) {
    reject(err);
  }
}

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    try {
      //捕获异常传给reject继续向下走
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    // 返回一个Promise 处理 .then的链式调用问题
    return new PZPromise((resolve, reject) => {
      // 1.如果在then调用的时候, 状态已经确定下来
      if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
        // try {
        //   const value = onFulfilled(this.value)
        //   resolve(value)
        // } catch(err) {
        //   reject(err)
        // }
        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
      }
      if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
        // try {
        //   const reason = onRejected(this.reason)
        //   resolve(reason)
        // } catch(err) {
        //   reject(err)
        // }
        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
      }

      // 2.将成功回调和失败的回调放到数组中
      if (this.status === PROMISE_STATUS_PENDING) {
        this.onFulfilledFns.push(() => {
          // try {
          //   const value = onFulfilled(this.value)
          //   resolve(value)
          // } catch(err) {
          //   reject(err)
          // }
          execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
        });
        this.onRejectedFns.push(() => {
          // try {
          //   const reason = onRejected(this.reason)
          //   resolve(reason)
          // } catch(err) {
          //   reject(err)
          // }
          execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
        });
      }
    });
  }
}

const promise = new PZPromise((resolve, reject) => {
  console.log("状态pending");
  // resolve(1111) // resolved/fulfilled
  reject(2222);
  // throw new Error("executor error message")
});

// 调用then方法多次调用
promise
  .then(
    (res) => {
      console.log("res1:", res);
      return "aaaa";
      // throw new Error("err message")
    },
    (err) => {
      console.log("err1:", err); //2222
      return "bbbbb";
      // throw new Error("err message")
    }
  )
  .then(
    (res) => {
      console.log("res2:", res); //bbbbb
    },
    (err) => {
      console.log("err2:", err);
    }
  );

```



#### 2.4.5 手写promise - catch 方法

**需求：**

1. 实现 `catch` 的错误捕获

**思路**

1. 利用已经实现 `then` 的第二个参数 onRejected 捕获 err
2. 因为 `.then` 是调用的第二个回调参数，所以要处理一下 第二个参数，如果没有值就使用自定义的函数，抛出异常让 `catch` 去捕获

```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

// 工具函数
// 返回resolve || reject
function execFunctionWithCatchError(execFn, value, resolve, reject) {
  try {
    const result = execFn(value);
    resolve(result);
  } catch (err) {
    reject(err);
  }
}

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    try {
      //捕获异常传给reject继续向下走
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    //因为catch是调用的.then
    //而.then抛出错误到下一个err中
    //所以定义抛出异常到第二个promise
    const defaultOnRejected = (err) => {
      throw err;
    };
    onRejected = onRejected || defaultOnRejected;
    // 返回一个Promise 处理 .then的链式调用问题
    return new PZPromise((resolve, reject) => {
      // 1.如果在then调用的时候, 状态已经确定下来
      if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
      }
      if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
      }

      // 2.将成功回调和失败的回调放到数组中
      if (this.status === PROMISE_STATUS_PENDING) {
        if (onFulfilled)
          this.onFulfilledFns.push(() => {
            execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
          });
        if (onRejected)
          this.onRejectedFns.push(() => {
            execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
          });
      }
    });
  }
  // 传给.then的err中
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
}

const promise = new PZPromise((resolve, reject) => {
  console.log("状态pending");
  // resolve(1111) // resolved/fulfilled
  reject(2222);
});

// 调用then方法多次调用
promise
  .then((res) => {
    console.log("res:", res);
  })
  .catch((err) => {
    console.log("err:", err); //'err:' 2222
    throw new Error("err message");
  })
  .then(
    (res) => {
      console.log("res1:", res);
    },
    (err) => {
      console.log("err1:", err); //err1 :err message
    }
  );

```

#### 2.4.5 手写promise - finally 方法

**需求：**

1. 实现 `finally ` 执行完成方法

**思路**

1. 同样调用 `.then` 方法并且在 `then` 两个参数都传入 finally方法

```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

// 工具函数
// 返回resolve || reject
function execFunctionWithCatchError(execFn, value, resolve, reject) {
  try {
    const result = execFn(value);
    resolve(result);
  } catch (err) {
    reject(err);
  }
}

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    try {
      //捕获异常传给reject继续向下走
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    //因为catch是调用的.then
    //而.then抛出错误到下一个err中
    //所以定义抛出异常到第二个promise
    const defaultOnRejected = (err) => {
      throw err;
    };
    onRejected = onRejected || defaultOnRejected;
    // 如果第二个链式调用是catch的话那么是没有onFulfilled的
    // 所以设置一个默认值继续往下走链式then函数
    const defaultOnFulfilled = (value) => {
      return value;
    };
    onFulfilled = onFulfilled || de faultOnFulfilled;
    // 返回一个Promise 处理 .then的链式调用问题
    return new PZPromise((resolve, reject) => {
      // 1.如果在then调用的时候, 状态已经确定下来
      if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
      }
      if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
      }

      // 2.将成功回调和失败的回调放到数组中
      if (this.status === PROMISE_STATUS_PENDING) {
        if (onFulfilled)
          this.onFulfilledFns.push(() => {
            execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
          });
        if (onRejected)
          this.onRejectedFns.push(() => {
            execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
          });
      }
    });
  }
// 传给.then的err中
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }

  finally(onFinally) {
    this.then(
      () => {
        onFinally();
      },
      () => {
        onFinally();
      }
    );
  }
}

const promise = new PZPromise((resolve, reject) => {
  console.log("状态pending");
  resolve(1111); // resolved/fulfilled
  // reject(2222)
});

// 调用then方法多次调用
promise
  .then((res) => {
    console.log("res1:", res);
    return "aaaaa";
  })
  .then((res) => {
    console.log("res2:", res);
  })
  .catch((err) => {
    console.log("err:", err);
  })
  .finally(() => {
    console.log("finally");
  });

```

#### 2.4.6 手写 Promise - resolve与reject 类方法

**需求：**

1. 实现 `resolve`与`reject ` 类方法

**思路**

1. 因为直接要在 class 上访问到的方法，那么一定会使用 `static` 设置为静态方法。
2. 而返回的其实本质还是一个 Promise 所以直接返回自己封装的 Promise 即可

```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

// 工具函数
// 返回resolve || reject
function execFunctionWithCatchError(execFn, value, resolve, reject) {
  try {
    const result = execFn(value);
    resolve(result);
  } catch (err) {
    reject(err);
  }
}

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    try {
      //捕获异常传给reject继续向下走
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    //因为catch是调用的.then
    //而.then抛出错误到下一个err中
    //所以定义抛出异常到第二个promise
    const defaultOnRejected = (err) => {
      throw err;
    };
    onRejected = onRejected || defaultOnRejected;
    // 如果第二个链式调用是catch的话那么是没有onFulfilled的
    // 所以设置一个默认值继续往下走链式then函数
    const defaultOnFulfilled = (value) => {
      return value;
    };
    onFulfilled = onFulfilled || defaultOnFulfilled;
    // 返回一个Promise 处理 .then的链式调用问题
    return new PZPromise((resolve, reject) => {
      // 1.如果在then调用的时候, 状态已经确定下来
      if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
      }
      if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
      }

      // 2.将成功回调和失败的回调放到数组中
      if (this.status === PROMISE_STATUS_PENDING) {
        if (onFulfilled)
          this.onFulfilledFns.push(() => {
            execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
          });
        if (onRejected)
          this.onRejectedFns.push(() => {
            execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
          });
      }
    });
  }
// 传给.then的err中
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }

  finally(onFinally) {
    this.then(
      () => {
        onFinally();
      },
      () => {
        onFinally();
      }
    );
  }
  // 开放静态类方法 resolve 直接返回一个 Promise 即可
  static resolve(value) {
    return new PZPromise((resolve) => resolve(value));
  }
  // 开放静态类方法 reject 直接返回一个 Promise 即可
  static reject(reason) {
    return new PZPromise((resolve, reject) => reject(reason));
  }
}

PZPromise.resolve("Hello World").then((res) => {
  console.log("res:", res);
});

PZPromise.reject("Error Message").catch((err) => {
  console.log("err:", err);
});

```



#### 2.4.7 手写 Promise - all 与 allSettled 类方法

**需求：** 

1. 实现类方法 `all` 的等待集合返回，并且如果有一个报错直接返回 `reject` 
2. 实现类方法 `allSettled` 的等待集合返回，只会并且只能返回 `resolve` 在返回值对象数组中标明状态 `fulfilled` 与 `rejected` 

**思路 ** 

1. all 的重点在于什么时候返回 `resolve` 或 `reject` 
   1. 创建一个数组，在then 的正确回调用 判断 `all`  的参数数组 与 定义的数组长度是否相等，如果相等那么就证明都是正确的，返回 `resolve` 
   2. 在`then`的错误中回调用，如果有错误直接将错误 `reject`出去 不等待
2. allSettled 的重点就是定义一个数组，在`then`的正确或者错误中都判断 参数数组 与 定义的数组长度是否相等 ，如果相等都调用 `resolve` 返回出去

```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

// 工具函数
// 返回resolve || reject
function execFunctionWithCatchError(execFn, value, resolve, reject) {
  try {
    const result = execFn(value);
    resolve(result);
  } catch (err) {
    reject(err);
  }
}

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    try {
      //捕获异常传给reject继续向下走
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    //因为catch是调用的.then
    //而.then抛出错误到下一个err中
    //所以定义抛出异常到第二个promise
    const defaultOnRejected = (err) => {
      throw err;
    };
    onRejected = onRejected || defaultOnRejected;
    // 如果第二个链式调用是catch的话那么是没有onFulfilled的
    // 所以设置一个默认值继续往下走链式then函数

    const defaultOnFulfilled = (value) => {
      return value;
    };
    onFulfilled = onFulfilled || defaultOnFulfilled;
    // 返回一个Promise 处理 .then的链式调用问题
    return new PZPromise((resolve, reject) => {
      // 1.如果在then调用的时候, 状态已经确定下来
      if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
      }
      if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
      }

      // 2.将成功回调和失败的回调放到数组中
      if (this.status === PROMISE_STATUS_PENDING) {
        if (onFulfilled)
          this.onFulfilledFns.push(() => {
            execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
          });
        if (onRejected)
          this.onRejectedFns.push(() => {
            execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
          });
      }
    });
  }
  // 传给.then的err中
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }

  finally(onFinally) {
    this.then(
      () => {
        onFinally();
      },
      () => {
        onFinally();
      }
    );
  }
  // 开放静态类方法 resolve 直接返回一个 Promise 即可
  static resolve(value) {
    return new PZPromise((resolve) => resolve(value));
  }
  // 开放静态类方法 reject 直接返回一个 Promise 即可
  static reject(reason) {
    return new PZPromise((resolve, reject) => reject(reason));
  }

  static all(promises) {
    // 问题关键: 什么时候要执行resolve, 什么时候要执行reject
    return new PZPromise((resolve, reject) => {
      const values = [];
      promises.forEach((promise) => {
        promise.then(
          (res) => {
            //向数组中存值
            values.push(res);
            //定义的数组与all传入的数组长度相同，证明循环完毕，执行resolve
            if (values.length === promises.length) {
              resolve(values);
            }
          },
          (err) => {
            reject(err); //只要是有错误直接reject返回出去
          }
        );
      });
    });
  }
  // allSettled 中只会执行 resolve，并且对象数组返回状态值和返回值
  static allSettled(promises) {
    return new PZPromise((resolve) => {
      const results = [];
      promises.forEach((promise) => {
        promise.then(
          (res) => {
            results.push({ status: PROMISE_STATUS_FULFILLED, value: res });
            if (results.length === promises.length) {
              resolve(results);
            }
          },
          (err) => {
            results.push({ status: PROMISE_STATUS_REJECTED, value: err });
            if (results.length === promises.length) {
              resolve(results);
            }
          }
        );
      });
    });
  }
}

const p1 = new Promise((resolve) => {
  setTimeout(() => {
    resolve(1111);
  }, 1000);
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(2222);
  }, 2000);
});
const p3 = new Promise((resolve) => {
  setTimeout(() => {
    resolve(3333);
  }, 3000);
});
// PZPromise.all([p1, p2, p3])
//   .then((res) => {
//     console.log("res", res);
//   })
//   .catch((err) => {
//     console.log("err", err);
//   });

PZPromise.allSettled([p1, p2, p3]).then((res) => {
  console.log(res);
});

```

#### 2.4.7 手写 Promise - race 与 any 类方法（Promise手写完成）

**需求：**

1. race 只要数组中有 `resolve` 或者 `reject` 其中一个返回，直接结束
2. any 多个捕获，只接收 **resolve** 返回值，并且有一个结束就直接回调 ，如果所有的都是 **reject** ，那么最后都执行完会进入 **catch** 返回一个数组，装载着多个 **promise** 的 **reject** 值

**思路:** 

1. 实现 `race` 无需考虑其他人，不过是正确还是错误直接回调。
2. 实现 `any` 需要考虑 到如果有正确就直接回调，如果都是错误那么就等待所有结束判断下长度之后返回。

**备注:**

1. 其中使用到了ES12新出的 API `AggregateError` 当多个错误需要包装在一个错误中时，该对象表示一个错误



```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

// 工具函数
// 返回resolve || reject
function execFunctionWithCatchError(execFn, value, resolve, reject) {
  try {
    const result = execFn(value);
    resolve(result);
  } catch (err) {
    reject(err);
  }
}

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    try {
      //捕获异常传给reject继续向下走
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    //因为catch是调用的.then
    //而.then抛出错误到下一个err中
    //所以定义抛出异常到第二个promise
    const defaultOnRejected = (err) => {
      throw err;
    };
    onRejected = onRejected || defaultOnRejected;
    // 如果第二个链式调用是catch的话那么是没有onFulfilled的
    // 所以设置一个默认值继续往下走链式then函数

    const defaultOnFulfilled = (value) => {
      return value;
    };
    onFulfilled = onFulfilled || defaultOnFulfilled;
    // 返回一个Promise 处理 .then的链式调用问题
    return new PZPromise((resolve, reject) => {
      // 1.如果在then调用的时候, 状态已经确定下来
      if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
      }
      if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
      }

      // 2.将成功回调和失败的回调放到数组中
      if (this.status === PROMISE_STATUS_PENDING) {
        if (onFulfilled)
          this.onFulfilledFns.push(() => {
            execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
          });
        if (onRejected)
          this.onRejectedFns.push(() => {
            execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
          });
      }
    });
  }
  // 传给.then的err中
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }

  finally(onFinally) {
    this.then(
      () => {
        onFinally();
      },
      () => {
        onFinally();
      }
    );
  }
  // 开放静态类方法 resolve 直接返回一个 Promise 即可
  static resolve(value) {
    return new PZPromise((resolve) => resolve(value));
  }
  // 开放静态类方法 reject 直接返回一个 Promise 即可
  static reject(reason) {
    return new PZPromise((resolve, reject) => reject(reason));
  }

  static all(promises) {
    // 问题关键: 什么时候要执行resolve, 什么时候要执行reject
    return new PZPromise((resolve, reject) => {
      const values = [];
      promises.forEach((promise) => {
        promise.then(
          (res) => {
            //向数组中存值
            values.push(res);
            //定义的数组与all传入的数组长度相同，证明循环完毕，执行resolve
            if (values.length === promises.length) {
              resolve(values);
            }
          },
          (err) => {
            reject(err); //只要是有错误直接reject返回出去
          }
        );
      });
    });
  }
  // allSettled 中只会执行 resolve，并且对象数组返回状态值和返回值
  static allSettled(promises) {
    return new PZPromise((resolve) => {
      const results = [];
      promises.forEach((promise) => {
        promise.then(
          (res) => {
            results.push({ status: PROMISE_STATUS_FULFILLED, value: res });
            if (results.length === promises.length) {
              resolve(results);
            }
          },
          (err) => {
            results.push({ status: PROMISE_STATUS_REJECTED, value: err });
            if (results.length === promises.length) {
              resolve(results);
            }
          }
        );
      });
    });
  }

  static race(promises) {
    return new PZPromise((resolve, reject) => {
      promises.forEach((promise) => {
        // promise.then(res => {
        //   resolve(res)
        // }, err => {
        //   reject(err)
        // })
        //只要有结果不管对错直接回调，不需要等其他人
        promise.then(resolve, reject);
      });
    });
  }

  static any(promises) {
    // resolve必须等到有一个成功的结果
    // reject所有的都失败才执行reject
    const reasons = [];
    return new PZPromise((resolve, reject) => {
      promises.forEach((promise) => {
        // 如果有一个正确就直接返回，否则进入err
        promise.then(resolve, (err) => {
          reasons.push(err);
          if (reasons.length === promises.length) {
            //AggregateError 当多个错误​​需要包装在一个错误中时，该对象表示一个错误
            reject(new AggregateError(reasons));
          }
        });
      });
    });
  }
}

const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(1111);
  }, 3000);
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(2222);
  }, 2000);
});
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(3333);
  }, 3000);
});

// PZPromise.race([p1, p2, p3]).then(res => {
//   console.log("res:", res)
// }).catch(err => {
//   console.log("err:", err)
// })

PZPromise.any([p1, p2, p3])
  .then((res) => {
    console.log("res:", res);
  })
  .catch((err) => {
    console.log("err:", err.errors);
  });

```



## 三、防抖节流



### 1、防抖

**定义**

+ 当事件触发时，相应的函数并不会立即触发，而是会**等待一定的时间**
+ 当事件**密集触发**时，函数的触发会被**频繁的推迟**
+ 只有等待了一定的时间**没有事件触发**，才会**执行响应函数**



### debounce-v1-基本实现

```js
function debounce(fn, delay) {
  // 1.定义一个定时器, 保存上一次的定时器
  let timer = null

  // 2.真正执行的函数
  const _debounce = function() {
    // 取消上一次的定时器
    if (timer) clearTimeout(timer)
    // 延迟执行
    timer = setTimeout(() => {
      // 外部传入的真正要执行的函数
      fn()
    }, delay)
  }

  return _debounce
}

```

### debounce-v2-this-参数

**实现**

+ 处理外部 this 指向与参数问题

**实现思路**

+ 因为外部实际调用的是 `_debounce` 函数，所以参数与this绑定在这个函数上
+ 写上形参，并在调用外部传入的函数时候将 `this` 与 `参数` 绑定返回去

```js
function debounce(fn, delay) {
  // 1.定义一个定时器, 保存上一次的定时器
  let timer = null;

  // 2.真正执行的函数
  // 传入参数(不明确多少参数使用展开运算)
  const _debounce = function (...args) {
    // 取消上一次的定时器
    if (timer) clearTimeout(timer);
    // 延迟执行
    timer = setTimeout(() => {
      // 外部传入的真正要执行的函数
      // 将this与参数传回去
      fn.apply(this, args);
    }, delay);
  };

  return _debounce;
}

```



### debounce-v3-立即执行

**实现**

+ 加入立即执行功能
+ **第一次**输入的信息**立即执行**，**以后**才开始**延时**，而延时执行完毕，**再一次**输入第一次一样是**立即执行**

**实现思路**

+ 让**外界**传入一个**参数**，通知是否需要立即执行
+ 内部定义一个**标记** 处理延时执行后的重新开始立即执行

```js
function debounce(fn, delay, immediate = false) {
  // 1.定义一个定时器, 保存上一次的定时器
  let timer = null
  let isInvoke = false

  // 2.真正执行的函数
  const _debounce = function(...args) {
    // 取消上一次的定时器
    if (timer) clearTimeout(timer)

    // 判断是否需要立即执行
    if (immediate && !isInvoke) {
      fn.apply(this, args)
      isInvoke = true
    } else {
      // 延迟执行
      timer = setTimeout(() => {
        // 外部传入的真正要执行的函数
        fn.apply(this, args)
        isInvoke = false
      }, delay)
    }
  }

  return _debounce
}


```

### debounce-v4-取消功能

**实现**

+ 加入取消功能

**实现思路**

+ 将函数内的定时器、标记点等关闭

```js
function debounce(fn, delay, immediate = false) {
  // 1.定义一个定时器, 保存上一次的定时器
  let timer = null;
  let isInvoke = false;

  // 2.真正执行的函数
  const _debounce = function (...args) {
    // 取消上一次的定时器
    if (timer) clearTimeout(timer);

    // 判断是否需要立即执行
    if (immediate && !isInvoke) {
      fn.apply(this, args);
      isInvoke = true;
    } else {
      // 延迟执行
      timer = setTimeout(() => {
        // 外部传入的真正要执行的函数
        fn.apply(this, args);
        isInvoke = false;
        timer = null;
      }, delay);
    }
  };

  // 封装取消功能
  _debounce.cancel = function () {
    if (timer) clearTimeout(timer);
    timer = null;
    isInvoke = false;
  };

  return _debounce;
}

```

### debounce-v5-函数返回值

**实现**

+ 加入返回值

**实现思路**

+ 使用回调函数 **callback**，或者返回一个 **Promise** 可以并用

```js
  const inputEl = document.querySelector("input")
    let counter = 0

    const inputChange = function (event) {
      console.log(`发送了第${++counter}次网络请求`, this, event)

      // 返回值
      return "aaaaaaaaaaaa"
    }

    // 防抖处理
    // inputEl.oninput = _.debounce(inputChange, 2000)
    const debounceChange = debounce(inputChange, 3000, false, (res) => {
      console.log("拿到真正执行函数的返回值:", res)
    })
    const tempCallback = () => {
      debounceChange().then(res => {
        console.log("Promise的返回值结果:", res)
      })
    }
    inputEl.oninput = tempCallback
```

```js
//传入回调函数resultCallback
function debounce(fn, delay, immediate = false, resultCallback) {
  // 1.定义一个定时器, 保存上一次的定时器
  let timer = null;
  let isInvoke = false;

  // 2.真正执行的函数
  const _debounce = function (...args) {
    return new Promise((resolve, reject) => {
      // 取消上一次的定时器
      if (timer) clearTimeout(timer);

      // 判断是否需要立即执行
      if (immediate && !isInvoke) {
        const result = fn.apply(this, args);
        if (resultCallback) resultCallback(result); //如果有回调则传出
        resolve(result); //将拿到的值resolve
        isInvoke = true;
      } else {
        // 延迟执行
        timer = setTimeout(() => {
          // 外部传入的真正要执行的函数
          const result = fn.apply(this, args);
          if (resultCallback) resultCallback(result); //如果有回调则传出
          resolve(result); //将拿到的值resolve
          isInvoke = false;
          timer = null;
        }, delay);
      }
    });
  };

  // 封装取消功能
  _debounce.cancel = function () {
    if (timer) clearTimeout(timer);
    timer = null;
    isInvoke = false;
  };

  return _debounce;
}
```







### 2、节流

**定义**

+ 当事件触发时，会执行这个事件的响应函数
+ 如果这个事件**频繁触发**，那么节流函数会**根据一定的频率执行响应函数**





### throttle-v1-基本实现

**实现思路**

+ 如果当前定时时间减去 (触发时间减去上次时间触发时间) 等于0那么就执行
+ remainTime = interval - (nowTime - lastTime)
+ .使用当前触发的时间和之前的时间间隔以及上一次开始的时间, 计算出还剩余多长事件需要去触发函数
+ 如果 `remainTime` 小于0或者等于0 那么就执行

```js
function throttle(fn, interval, options) {
  // 1.记录上一次的开始时间
  let lastTime = 0

  // 2.事件触发时, 真正执行的函数
  const _throttle = function() {

    // 2.1.获取当前事件触发时的时间
    const nowTime = new Date().getTime()

    // 2.2.使用当前触发的时间和之前的时间间隔以及上一次开始的时间, 计算出还剩余多长事件需要去触发函数
    const remainTime = interval - (nowTime - lastTime)
    if (remainTime <= 0) {
      // 2.3.真正触发函数
      fn()
      // 2.4.保留上次触发的时间
      lastTime = nowTime
    }
  }

  return _throttle
}

```

### throttle-v2-leading实现

**实现**

+ 第一次输入执行或者不执行（ leading ）

**实现思路**

+ 传入一个配置项标记
+ 将 上次时间 `lastTime` 设置为 触发时间即可

```js
/**
 *
 * @param {*} fn 函数
 * @param {*} interval 时长
 * @param {*} options leading 第一次是否触发 trailing最后是否触发
 * @returns
 */
function throttle(fn, interval, options = { leading: true, trailing: false }) {
  // 1.记录上一次的开始时间
  const { leading, trailing } = options;
  let lastTime = 0;

  // 2.事件触发时, 真正执行的函数
  const _throttle = function () {
    // 2.1.获取当前事件触发时的时间
    const nowTime = new Date().getTime();
    if (!lastTime && !leading) lastTime = nowTime;

    // 2.2.使用当前触发的时间和之前的时间间隔以及上一次开始的时间, 计算出还剩余多长事件需要去触发函数
    const remainTime = interval - (nowTime - lastTime);
    if (remainTime <= 0) {
      // 2.3.真正触发函数
      fn();
      // 2.4.保留上次触发的时间
      lastTime = nowTime;
    }
  };

  return _throttle;
}

```

### throttle-v3-traling实现

**实现**

+ 处理**最后不到频率**的剩余键入值，**执行一次**

**实现思路**

+ 创建一个 timer 变量
+ 如果满足 **trailing =  true** 与 有**timer**，那么就把**还有多长时间 remainTime** 作为 timer 定时器的时长
  + 并在定时器函数中将，timer 上次时间 `lastTime` 等处理一下
  + 不可以将lastTime直接设置为0，避免执行几毫秒的差，这里执行一次，正常逻辑又执行一次
+ 在**正常执行逻辑**中，将 **timer 关掉**，并且 **return 掉 最后定时器的执行** 

```js
/**
 *
 * @param {*} fn 函数
 * @param {*} interval 时长
 * @param {*} options leading 第一次是否触发 trailing最后是否触发
 * @returns
 */
function throttle(fn, interval, options = { leading: true, trailing: false }) {
  // 1.记录上一次的开始时间
  const { leading, trailing } = options;
  let lastTime = 0;
  let timer = null;

  // 2.事件触发时, 真正执行的函数
  const _throttle = function () {
    // 2.1.获取当前事件触发时的时间
    const nowTime = new Date().getTime();
    if (!lastTime && !leading) lastTime = nowTime;

    // 2.2.使用当前触发的时间和之前的时间间隔以及上一次开始的时间, 计算出还剩余多长事件需要去触发函数
    const remainTime = interval - (nowTime - lastTime);
    if (remainTime <= 0) {
      if (timer) {
        //如果正常执行，需要关闭最后 trailing 函数
        clearTimeout(timer);
        timer = null;
      }

      // 2.3.真正触发函数
      fn();
      // 2.4.保留上次触发的时间
      lastTime = nowTime;
      return;
    }
    // 处理最后不到时间内的键入值
    // 执行最后一次请求
    if (trailing && !timer) {
      timer = setTimeout(() => {
        timer = null;
        // 不可以将lastTime直接设置为0
        // 避免执行几毫秒的差，这里执行一次，上边正常逻辑又执行一次
        lastTime = !leading ? 0 : new Date().getTime();
        fn();
      }, remainTime);
    }
  };

  return _throttle;
}

```

### throttle-v4-this-参数

**实现**

+ this 与 参数 的添加

**实现思路**

+ 在实际调用函数上解构参数
+ 在传入函数调用，绑定 `this` 和 `参数`

```js
/**
 *
 * @param {*} fn 函数
 * @param {*} interval 时长
 * @param {*} options leading 第一次是否触发 trailing最后是否触发
 * @returns
 */
function throttle(fn, interval, options = { leading: true, trailing: false }) {
  // 1.记录上一次的开始时间
  const { leading, trailing } = options;
  let lastTime = 0;
  let timer = null;

  // 2.事件触发时, 真正执行的函数
  const _throttle = function (...args) {
    // 2.1.获取当前事件触发时的时间
    const nowTime = new Date().getTime();
    if (!lastTime && !leading) lastTime = nowTime;

    // 2.2.使用当前触发的时间和之前的时间间隔以及上一次开始的时间, 计算出还剩余多长事件需要去触发函数
    const remainTime = interval - (nowTime - lastTime);
    if (remainTime <= 0) {
      if (timer) {
        //如果正常执行，需要关闭最后 trailing 函数
        clearTimeout(timer);
        timer = null;
      }

      // 2.3.真正触发函数
      fn.apply(this, args);
      // 2.4.保留上次触发的时间
      lastTime = nowTime;
      return;
    }
    // 处理最后不到时间内的键入值
    // 执行最后一次请求
    if (trailing && !timer) {
      timer = setTimeout(() => {
        timer = null;
        // 不可以将lastTime直接设置为0
        // 避免执行几毫秒的差，这里执行一次，上边正常逻辑又执行一次
        lastTime = !leading ? 0 : new Date().getTime();
        fn.apply(this, args);
      }, remainTime);
    }
  };

  return _throttle;
}

```

### throttle-v5-取消功能

**实现**

+ 加入取消功能

**实现思路**

+ 点击取消**关闭定时器**并将**所有置为初始值**

```js
/**
 *
 * @param {*} fn 函数
 * @param {*} interval 时长
 * @param {*} options leading 第一次是否触发 trailing最后是否触发
 * @returns
 */
function throttle(fn, interval, options = { leading: true, trailing: false }) {
  // 1.记录上一次的开始时间
  const { leading, trailing } = options;
  let lastTime = 0;
  let timer = null;

  // 2.事件触发时, 真正执行的函数
  const _throttle = function (...args) {
    // 2.1.获取当前事件触发时的时间
    const nowTime = new Date().getTime();
    if (!lastTime && !leading) lastTime = nowTime;

    // 2.2.使用当前触发的时间和之前的时间间隔以及上一次开始的时间, 计算出还剩余多长事件需要去触发函数
    const remainTime = interval - (nowTime - lastTime);
    if (remainTime <= 0) {
      if (timer) {
        //如果正常执行，需要关闭最后 trailing 函数
        clearTimeout(timer);
        timer = null;
      }

      // 2.3.真正触发函数
      fn.apply(this, args);
      // 2.4.保留上次触发的时间
      lastTime = nowTime;
      return;
    }
    // 处理最后不到时间内的键入值
    // 执行最后一次请求
    if (trailing && !timer) {
      timer = setTimeout(() => {
        timer = null;
        // 不可以将lastTime直接设置为0
        // 避免执行几毫秒的差，这里执行一次，上边正常逻辑又执行一次
        lastTime = !leading ? 0 : new Date().getTime();
        fn.apply(this, args);
      }, remainTime);
    }
  };
  // 取消功能
  _throttle.cancel = function () {
    if (timer) clearTimeout(timer);
    timer = null;
    lastTime = 0;
  };

  return _throttle;
}

```

### throttle-v6-函数返回值

**实现**

+ 加入返回值

**实现思路**

+ 使用回调函数 **callback**，或者返回一个 **Promise** 可以并用

```js
/**
 *
 * @param {*} fn 函数
 * @param {*} interval 时长
 * @param {*} options leading 第一次是否触发 trailing最后是否触发 resultCallback 回调函数
 * @returns
 */
function throttle(fn, interval, options = { leading: true, trailing: false }) {
  // 1.记录上一次的开始时间
  const { leading, trailing, resultCallback } = options;
  let lastTime = 0;
  let timer = null;

  // 2.事件触发时, 真正执行的函数
  const _throttle = function (...args) {
    return new Promise((resolve, reject) => {
      // 2.1.获取当前事件触发时的时间
      const nowTime = new Date().getTime();
      if (!lastTime && !leading) lastTime = nowTime;

      // 2.2.使用当前触发的时间和之前的时间间隔以及上一次开始的时间, 计算出还剩余多长事件需要去触发函数
      const remainTime = interval - (nowTime - lastTime);
      if (remainTime <= 0) {
        if (timer) {
          //如果正常执行，需要关闭最后 trailing 函数
          clearTimeout(timer);
          timer = null;
        }

        // 2.3.真正触发函数
        const result = fn.apply(this, args);
        if (resultCallback) resultCallback(result);
        resolve(result);
        // 2.4.保留上次触发的时间
        lastTime = nowTime;
        return;
      }

      // 处理最后不到时间内的键入值
      // 执行最后一次请求
      if (trailing && !timer) {
        timer = setTimeout(() => {
          timer = null;
          // 不可以将lastTime直接设置为0
          // 避免执行几毫秒的差，这里执行一次，上边正常逻辑又执行一次
          lastTime = !leading ? 0 : new Date().getTime();
          const result = fn.apply(this, args);
          if (resultCallback) resultCallback(result);
          resolve(result);
        }, remainTime);
      }
    });
  };

  _throttle.cancel = function () {
    if (timer) clearTimeout(timer);
    timer = null;
    lastTime = 0;
  };

  return _throttle;
}

```



## 四、深拷贝

### 1、三种拷贝

+ 引入的赋值：指向同一个对象，相互之间会影响
  + 引用内存地址指向一个地址
+ 对象的浅拷贝：只是浅层的拷贝，内部引入对象时，依然会相互影响； 
  + `Object.assign({},obj)` 这里第一层可以深拷贝，但是对象引用的还是同一个地址
+ 对象的深拷贝：两个对象不再有任何关系，不会相互影响；
  +  `JSON.parse(JSON.stringify())`



**JSON.parse(JSON.stringify()) 弊端**

+ 对于函数、Symbol等是无法处理的
+ 并且存在对象的循环引用，也会报错的 (window.window.window)



### 实现深拷贝函数v1-基本实现

**实现**

+ 实现深拷贝

**实现思路**

+ 在一个函数中**创建一个新对象**将赋值对象**循环出来赋值给新对象**

```js
function isObject(value) {
  const valueType = typeof value;
  return value !== null && (valueType === "object" || valueType === "function");
}

function deepClone(originValue) {
  // 判断传入的originValue是否是一个对象类型
  if (!isObject(originValue)) {
    return originValue;
  }

  const newObject = {};
  for (const key in originValue) {
    newObject[key] = deepClone(originValue[key]);
  }
  return newObject;
}

// 测试代码
const obj = {
  name: "lpz",
  age: 18,
  friend: {
    name: "james",
    address: {
      city: "北京",
    },
  },
};

const newObj = deepClone(obj);
console.log(newObj === obj);

obj.friend.name = "kobe";
obj.friend.address.city = "杭州";
console.log(newObj);

```

### 实现深拷贝函数v2-其他类型

**实现**

+ 处理其他类型

**实现思路**

+ 在函数中针对指定类型处理



```js
function isObject(value) {
  const valueType = typeof value;
  return value !== null && (valueType === "object" || valueType === "function");
}

function deepClone(originValue) {
  // 判断是否是一个Set类型
  if (originValue instanceof Set) {
    return new Set([...originValue]);
  }

  // 判断是否是一个Map类型
  if (originValue instanceof Map) {
    return new Map([...originValue]);
  }

  // 判断如果是Symbol的value, 那么创建一个新的Symbol
  if (typeof originValue === "symbol") {
    return Symbol(originValue.description);
  }

  // 判断如果是函数类型, 那么直接使用同一个函数
  if (typeof originValue === "function") {
    return originValue;
  }

  // 判断传入的originValue是否是一个对象类型
  if (!isObject(originValue)) {
    return originValue;
  }

  // 判断传入的对象是数组, 还是对象
  const newObject = Array.isArray(originValue) ? [] : {};
  for (const key in originValue) {
    newObject[key] = deepClone(originValue[key]);
  }

  // 对Symbol的key进行特殊的处理
  const symbolKeys = Object.getOwnPropertySymbols(originValue);
  for (const sKey of symbolKeys) {
    // const newSKey = Symbol(sKey.description)
    newObject[sKey] = deepClone(originValue[sKey]);
  }

  return newObject;
}

// 测试代码
let s1 = Symbol("aaa");
let s2 = Symbol("bbb");

const obj = {
  name: "why",
  age: 18,
  friend: {
    name: "james",
    address: {
      city: "广州",
    },
  },
  // 数组类型
  hobbies: ["abc", "cba", "nba"],
  // 函数类型
  foo: function (m, n) {
    console.log("foo function");
    console.log("100代码逻辑");
    return 123;
  },
  // Symbol作为key和value
  [s1]: "abc",
  s2: s2,
  // Set/Map
  set: new Set(["aaa", "bbb", "ccc"]),
  map: new Map([
    ["aaa", "abc"],
    ["bbb", "cba"],
  ]),
};

const newObj = deepClone(obj);
console.log(newObj === obj);

obj.friend.name = "kobe";
obj.friend.address.city = "成都";
console.log(newObj);
console.log(newObj.s2 === obj.s2);

```



### 实现深拷贝函数v3-循环引用

**实现**

+ 处理循环引用
  + obj.info = obj
  + 这样调用函数时候会出现死循环，栈溢出

**实现思路**

+ 创建一个 **WeakMap** 每次将调用的参数传入，如果下次发现有同样的键，直接返回

```js
function isObject(value) {
  const valueType = typeof value;
  return value !== null && (valueType === "object" || valueType === "function");
}
// 使用WeakMap的好处是因为WeakMap是弱引用，其他对象不引用即便是WeakMap引用了垃圾回收机制也会销毁
function deepClone(originValue, map = new WeakMap()) {
  // 判断是否是一个Set类型
  if (originValue instanceof Set) {
    return new Set([...originValue]);
  }

  // 判断是否是一个Map类型
  if (originValue instanceof Map) {
    return new Map([...originValue]);
  }

  // 判断如果是Symbol的value, 那么创建一个新的Symbol
  if (typeof originValue === "symbol") {
    return Symbol(originValue.description);
  }

  // 判断如果是函数类型, 那么直接使用同一个函数
  if (typeof originValue === "function") {
    return originValue;
  }

  // 判断传入的originValue是否是一个对象类型
  if (!isObject(originValue)) {
    return originValue;
  }
  // 处理循环引用，判断有同样的值直接return出去
  if (map.has(originValue)) {
    return map.get(originValue);
  }

  // 判断传入的对象是数组, 还是对象
  const newObject = Array.isArray(originValue) ? [] : {};
  map.set(originValue, newObject);
  for (const key in originValue) {
    newObject[key] = deepClone(originValue[key], map);
  }

  // 对Symbol的key进行特殊的处理
  const symbolKeys = Object.getOwnPropertySymbols(originValue);
  for (const sKey of symbolKeys) {
    // const newSKey = Symbol(sKey.description)
    newObject[sKey] = deepClone(originValue[sKey], map);
  }

  return newObject;
}

// deepClone({name: "why"})

// 测试代码
let s1 = Symbol("aaa");
let s2 = Symbol("bbb");

const obj = {
  name: "lpz",
  age: 18,
  friend: {
    name: "james",
    address: {
      city: "北京",
    },
  },
  // 数组类型
  hobbies: ["abc", "cba", "nba"],
  // 函数类型
  foo: function (m, n) {
    console.log("foo function");
    console.log("100代码逻辑");
    return 123;
  },
  // Symbol作为key和value
  [s1]: "abc",
  s2: s2,
  // Set/Map
  set: new Set(["aaa", "bbb", "ccc"]),
  map: new Map([
    ["aaa", "abc"],
    ["bbb", "cba"],
  ]),
};

obj.info = obj;

const newObj = deepClone(obj);
console.log(newObj === obj);

obj.friend.name = "kobe";
obj.friend.address.city = "杭州";
console.log(newObj);
console.log(newObj.s2 === obj.s2);

console.log(newObj.info.info.info);

```



## 五、自定义事件

### 定义

+ 自定义事件总线属于一种观察者模式，其中包括三个角色
  + 发布者（Publisher）：发出事件（Event）；
  + 订阅者（Subscriber）：订阅事件（Event），并且会进行响应（Handler）；
  + 事件总线（EventBus）：无论是发布者还是订阅者都是通过事件总线作为中台的；



### 实现

+ 利用 Class 实现 on、off、emit

```js
class HYEventBus {
  constructor() {
    this.eventBus = {};
  }

  on(eventName, eventCallback, thisArg) {
    let handlers = this.eventBus[eventName];
    if (!handlers) {
      handlers = [];
      this.eventBus[eventName] = handlers;
    }
    // 浅拷贝直接赋值当前变量 Class中也会变
    handlers.push({
      eventCallback,
      thisArg,
    });
  }

  off(eventName, eventCallback) {
    const handlers = this.eventBus[eventName];
    if (!handlers) return;
    const newHandlers = [...handlers];
    for (let i = 0; i < newHandlers.length; i++) {
      const handler = newHandlers[i];
      if (handler.eventCallback === eventCallback) {
        const index = handlers.indexOf(handler);
        handlers.splice(index, 1); //删除某个事件
      }
    }
  }

  emit(eventName, ...payload) {
    const handlers = this.eventBus[eventName];
    if (!handlers) return;
    handlers.forEach((handler) => {
      handler.eventCallback.apply(handler.thisArg, payload);
    });
  }
}

const eventBus = new HYEventBus();

// main.js
eventBus.on(
  "abc",
  function () {
    console.log("监听abc1", this);
  },
  { name: "pz" }
);

const handleCallback = function () {
  console.log("监听abc2", this);
};
eventBus.on("abc", handleCallback, { name: "lpz" });

// utils.js
eventBus.emit("abc", 123);

// 移除监听
eventBus.off("abc", handleCallback);
eventBus.emit("abc", 123);

```




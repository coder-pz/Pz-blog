# 探索原理与实现

## 一、响应式原理

### 1.1 什么是响应式

+ 在一些值变化时，一些函数或者语句做出来一些反应或响应，就叫做响应式

```js
// let m = 100

// // 一段代码
// console.log(m)
// console.log(m * 2)
// console.log(m ** 2)
// console.log("Hello World")

// m = 200// m变化上边代码重新执行这就叫做响应式

// 对象的响应式
const obj = {
  name: "why",
  age: 18
}

const newName = obj.name
console.log("你好啊, 李银河")
console.log("Hello World")
console.log(obj.name) // 100行
obj.name = "kobe"//obj中的name 变化上边代码重新执行这就叫做对象的响应式


```

### 1.2 响应式函数封装

#### 1.2.1 使用函数 1.0手动版本(只针对指定变量)

```js
/**
 * 响应式函数 针对某一个指定变量手动调用
 */


// 封装一个响应式的函数
let reactiveFns = []//装载需要响应式调用的函数
function watchFn(fn) {//创建响应式函数
  reactiveFns.push(fn)
}

// 对象的响应式
const obj = {
  name: "why",
  age: 18
}

watchFn(function() {//将需要响应式调用的函数传入
  const newName = obj.name
  console.log("你好啊, 李银河")
  console.log("Hello World")
  console.log(obj.name) // 100行
})

watchFn(function() {//将需要响应式调用的函数传入
  console.log(obj.name, "demo function -------")
})

function bar() {
  console.log("普通的其他函数")
  console.log("这个函数不需要有任何响应式")
}

obj.name = "kobe"//当obj.name变化时候 循环调用 需要响应式的函数
reactiveFns.forEach(fn => {
  fn()
})

```

#### 1.2.2 使用 类 函数 2.0手动版本(只针对指定变量)

```js
class Depend {
  constructor() {//每次new一个新的数据
    this.reactiveFns = []
  }

  addDepend(reactiveFn) {//将需要响应的函数传入
    this.reactiveFns.push(reactiveFn)
  }

  notify() {//调用需要响应的函数
    this.reactiveFns.forEach(fn => {
      fn()
    })
  }
}

// 封装一个响应式的函数
const depend = new Depend()
function watchFn(fn) {
  depend.addDepend(fn)
}

// 对象的响应式
const obj = {
  name: "why", // depend对象
  age: 18 // depend对象
}

watchFn(function() {
  const newName = obj.name
  console.log("你好啊, 李银河")
  console.log("Hello World")
  console.log(obj.name) // 100行
})

watchFn(function() {
  console.log(obj.name, "demo function -------")
})

obj.name = "kobe"
depend.notify()

```

#### 1.2.3 使用Proxy监听 3.0自动版本(只针对指定变量)

+ 响应式监听
  + **Vue2** 使用的是 **Object.defineProperty()**
  + **Vue3** 使用的是 **Proxy()**

```js
class Depend {
  constructor() {//每次new一个新的数据
    this.reactiveFns = []
  }

  addDepend(reactiveFn) {//将需要响应的函数传入
    this.reactiveFns.push(reactiveFn)
  }

  notify() {//调用需要响应的函数
    this.reactiveFns.forEach(fn => {
      fn()
    })
  }
}

// 封装一个响应式的函数
const depend = new Depend()
function watchFn(fn) {
  depend.addDepend(fn)
}

// 对象的响应式
const obj = {
  name: "why", // depend对象
  age: 18 // depend对象
}

// 监听对象的属性变量: Proxy(vue3)/Object.defineProperty(vue2)
const objProxy = new Proxy(obj, {
  get: function(target, key, receiver) {
    return Reflect.get(target, key, receiver)
  },
  set: function(target, key, newValue, receiver) {//监听值变化调用响应式方法
    Reflect.set(target, key, newValue, receiver)
    depend.notify()
  }
})

watchFn(function() {
  const newName = objProxy.name
  console.log("你好啊, 李银河")
  console.log("Hello World")
  console.log(objProxy.name) // 100行
})

watchFn(function() {
  console.log(objProxy.name, "demo function -------")
})

watchFn(function() {
  console.log(objProxy.age, "age 发生变化是需要执行的----1")
})

watchFn(function() {
  console.log(objProxy.age, "age 发生变化是需要执行的----2")
})

objProxy.name = "kobe"
objProxy.name = "james"
objProxy.name = "curry"

objProxy.age = 100

```



#### 1.2.4 使用map与weekMap 绑定指定对象的响应式函数 4.0版本

```js
class Depend {
  constructor() {
    this.reactiveFns = []
  }

  addDepend(reactiveFn) {
    this.reactiveFns.push(reactiveFn)
  }

  notify() {
    this.reactiveFns.forEach(fn => {
      fn()
    })
  }
}

// 封装一个响应式的函数
const depend = new Depend()
function watchFn(fn) {
  depend.addDepend(fn)
}

// 封装一个获取指定key的depend函数
const targetMap = new WeakMap()
function getDepend(target, key) {
  // 根据target对象获取map的过程
  let map = targetMap.get(target)
  if (!map) {//第一次没有target对应的值则创建一个
    map = new Map()
    targetMap.set(target, map)
  }

  // 根据key获取depend对象
  let depend = map.get(key)
  if (!depend) {//第一次map中没有key对应的值则创建一个
    depend = new Depend()
    map.set(key, depend)
  }
  return depend
}

// 对象的响应式
const obj = {
  name: "why", // depend对象
  age: 18 // depend对象
}

// 监听对象的属性变量: Proxy(vue3)/Object.defineProperty(vue2)
const objProxy = new Proxy(obj, {
  get: function(target, key, receiver) {
    return Reflect.get(target, key, receiver)
  },
  set: function(target, key, newValue, receiver) {
    Reflect.set(target, key, newValue, receiver)
    // depend.notify()
    const depend = getDepend(target, key)//获取到指定key的depend类
    depend.notify()
  }
})

watchFn(function() {
  const newName = objProxy.name
  console.log("你好啊, 李银河")
  console.log("Hello World")
  console.log(objProxy.name) // 100行
})

watchFn(function() {
  console.log(objProxy.name, "demo function -------")
})

watchFn(function() {
  console.log(objProxy.age, "age 发生变化是需要执行的----1")
})

watchFn(function() {
  console.log(objProxy.age, "age 发生变化是需要执行的----2")
})

objProxy.name = "kobe"
objProxy.name = "james"
objProxy.name = "curry"

objProxy.age = 100


const info = {
  name: "kobe",
  address: "广州市"
}

watchFn(function() {
  console.log(info.address, "监听address变化+++++++++1")
})

watchFn(function() {
  console.log(info.address, "监听address变化+++++++++2")
})

// obj对象
// name: depend
// age: depend
// const objMap = new Map()
// objMap.set("name", "nameDepend")
// objMap.set("age", "ageDepend")

// // info对象
// // address: depend
// // name: depend
// const infoMap = new Map()
// infoMap.set("address", "addressDepend")


// const targetMap = new WeakMap()
// targetMap.set(obj, objMap)
// targetMap.set(info, infoMap)

// // obj.name
// const depend = targetMap.get(obj).get("name")
// depend.notify()

```

#### 1.2.5 5.0版本响应式针对对象中的key绑定

```js
class Depend {
  constructor() {
    this.reactiveFns = [];
  }

  addDepend(reactiveFn) {
    this.reactiveFns.push(reactiveFn);
  }

  notify() {
    console.log(this.reactiveFns);
    this.reactiveFns.forEach((fn) => {
      fn();
    });
  }
}

// 封装一个响应式的函数
let activeReactiveFn = null;
function watchFn(fn) {
  activeReactiveFn = fn;
  fn();
  activeReactiveFn = null;
}

// 封装一个获取指定key的depend函数
const targetMap = new WeakMap();
function getDepend(target, key) {
  // 根据target对象获取map的过程
  let map = targetMap.get(target);
  if (!map) {
    //第一次没有target对应的值则创建一个
    map = new Map();
    targetMap.set(target, map);
  }

  // 根据key获取depend对象
  let depend = map.get(key);
  if (!depend) {
    //第一次map中没有key对应的值则创建一个
    depend = new Depend();
    map.set(key, depend);
  }
  return depend;
}

// 对象的响应式
const obj = {
  name: "why", // depend对象
  age: 18, // depend对象
};

// 监听对象的属性变量: Proxy(vue3)/Object.defineProperty(vue2)
const objProxy = new Proxy(obj, {
  get: function (target, key, receiver) {
    // 根据target.key获取对应的depend
    const depend = getDepend(target, key);
    // 给depend对象中添加响应函数
    depend.addDepend(activeReactiveFn); //第一次初始化会调用所有函数并且走这里

    return Reflect.get(target, key, receiver);
  },
  set: function (target, key, newValue, receiver) {
    Reflect.set(target, key, newValue, receiver);
    // depend.notify()
    const depend = getDepend(target, key); //获取到指定key的depend类
    depend.notify();
  },
});

watchFn(function () {
  console.log("-----第一个name函数开始------");
  console.log("你好啊, 李银河");
  console.log("Hello World");
  console.log(objProxy.name); // 100行
  console.log("-----第一个name函数结束------");
});

watchFn(function () {
  console.log(objProxy.name, "demo function -------");
});

watchFn(function () {
  console.log(objProxy.age, "age 发生变化是需要执行的----1");
});

watchFn(function () {
  console.log(objProxy.age, "age 发生变化是需要执行的----2");
});

watchFn(function () {
  console.log(objProxy.name, "新函数");
  console.log(objProxy.age, "新函数");
});

console.log("------------------------------改变obj的name值");

objProxy.name = "kobe";
// objProxy.name = "james"

// objProxy.age = 20
// objProxy.age = 30

```

#### 1.2.6 终版 6.0 版本对象的响应式操作 (reactive)

```js
// 保存当前需要收集的响应式函数
let activeReactiveFn = null;

/**
 * Depend优化:
 *  1> depend方法
 *  2> 使用Set来保存依赖函数, 而不是数组[]
 */

class Depend {
  constructor() {
    this.reactiveFns = new Set(); //避免重复
  }

  // addDepend(reactiveFn) {
  //   this.reactiveFns.add(reactiveFn)
  // }

  depend() {
    if (activeReactiveFn) {
      this.reactiveFns.add(activeReactiveFn);
    }
  }

  notify() {
    this.reactiveFns.forEach((fn) => {
      fn();
    });
  }
}

// 封装一个响应式的函数
function watchFn(fn) {
  activeReactiveFn = fn;
  fn();
  activeReactiveFn = null;
}

// 封装一个获取depend函数
const targetMap = new WeakMap();
function getDepend(target, key) {
  // 根据target对象获取map的过程
  let map = targetMap.get(target);
  if (!map) {
    map = new Map();
    targetMap.set(target, map);
  }

  // 根据key获取depend对象
  let depend = map.get(key);
  if (!depend) {
    depend = new Depend();
    map.set(key, depend);
  }
  return depend;
}

function reactive(obj) {
  return new Proxy(obj, {
    get: function (target, key, receiver) {
      // 根据target.key获取对应的depend
      const depend = getDepend(target, key);
      // 给depend对象中添加响应函数
      // depend.addDepend(activeReactiveFn)
      depend.depend();

      return Reflect.get(target, key, receiver);
    },
    set: function (target, key, newValue, receiver) {
      Reflect.set(target, key, newValue, receiver);
      // depend.notify()
      const depend = getDepend(target, key);
      depend.notify();
    },
  });
}

// 监听对象的属性变量: Proxy(vue3)/Object.defineProperty(vue2)
const objProxy = reactive({
  name: "why", // depend对象
  age: 18, // depend对象
});

const infoProxy = reactive({
  address: "广州市",
  height: 1.88,
});

watchFn(() => {
  console.log(infoProxy.address);
});

infoProxy.address = "北京市";

const foo = reactive({
  name: "foo",
});

watchFn(() => {
  console.log(foo.name);
});

foo.name = "bar";

```

### 1.3 仿造Vue2响应式原理 （Object.defineProperty）



```js
// 保存当前需要收集的响应式函数
let activeReactiveFn = null

/**
 * Depend优化:
 *  1> depend方法
 *  2> 使用Set来保存依赖函数, 而不是数组[]
 */

class Depend {
  constructor() {
    this.reactiveFns = new Set()
  }

  // addDepend(reactiveFn) {
  //   this.reactiveFns.add(reactiveFn)
  // }

  depend() {
    if (activeReactiveFn) {
      this.reactiveFns.add(activeReactiveFn)
    }
  }

  notify() {
    this.reactiveFns.forEach(fn => {
      fn()
    })
  }
}

// 封装一个响应式的函数
function watchFn(fn) {
  activeReactiveFn = fn
  fn()
  activeReactiveFn = null
}

// 封装一个获取depend函数
const targetMap = new WeakMap()
function getDepend(target, key) {
  // 根据target对象获取map的过程
  let map = targetMap.get(target)
  if (!map) {
    map = new Map()
    targetMap.set(target, map)
  }

  // 根据key获取depend对象
  let depend = map.get(key)
  if (!depend) {
    depend = new Depend()
    map.set(key, depend)
  }
  return depend
}

function reactive(obj) {
  // {name: "why", age: 18}
  // ES6之前, 使用Object.defineProperty
  Object.keys(obj).forEach(key => {
    let value = obj[key]
    Object.defineProperty(obj, key, {
      get: function() {
        const depend = getDepend(obj, key)
        depend.depend()
        return value
      },
      set: function(newValue) {
        value = newValue
        const depend = getDepend(obj, key)
        depend.notify()
      }
    })
  })
  return obj
}

// 监听对象的属性变量: Proxy(vue3)/Object.defineProperty(vue2)
const objProxy = reactive({
  name: "why", // depend对象
  age: 18 // depend对象
})

const infoProxy = reactive({
  address: "广州市",
  height: 1.88
})

watchFn(() => {
  console.log(infoProxy.address)
})

infoProxy.address = "北京市"

const foo = reactive({
  name: "foo"
})

watchFn(() => {
  console.log(foo.name)
})

foo.name = "bar"
foo.name = "hhh"

```



## 二、Promise

### 2.1 promise 三个状态

+ 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝
  + 当执行executor中的代码时，处于该状态
+ 已兑现（fulfilled）: 意味着操作成功完成；
  + 执行了resolve时，处于该状态
+ 已拒绝（rejected）: 意味着操作失败
  + 执行了reject时，处于该状态

>  Promise状态一旦确定下来, 那么就不能再进入其他状态



```js
// 注意: Promise状态一旦确定下来, 那么就是不可更改的(锁定)
new Promise((resolve, reject) => {
  // pending状态: 待定/悬而未决的
  console.log("--------")
  reject() // 处于rejected状态(已拒绝状态)
  resolve() // 处于fulfilled状态(已敲定/兑现状态)
  console.log("++++++++++++")
}).then(res => {
  console.log("res:", res)
}, err => {
  console.log("err:", err)
})

```

### 2.2 promise resolve的参数三种形式

+  普通的值或者对象  pending(等待) -> fulfilled(完成)
+  传入一个promise
   + 如果传入一个promise 那么当前 promise 的状态将会移交给传入的 promise
+  传入一个对象, 并且这个对象有实现then方法(并且这个对象是实现了thenable接口) 那么也会执行该then方法, 并且由该then方法决定后续状态

> "thenable"是定义`then`方法的对象或函数。

**1、传入promise**

```js
const newPromise = new Promise((resolve, reject) => {
  // resolve("aaaaaa")
  reject("err message")
})

new Promise((resolve, reject) => {
  // pending -> fulfilled
  resolve(newPromise)//将状态移交给传入的promise
}).then(res => {
  console.log("res:", res)
}, err => {
  console.log("err:", err)
})
```

**2、传入一个对象，并且这个对象有then方法**

```js
// 2.传入一个对象, 这个兑现有then方法
new Promise((resolve, reject) => {
  // pending -> fulfilled
  const obj = {
    then: function (resolve, reject) {
      // resolve("resolve message")
      reject("reject message");
    },
  };
  resolve(obj);
}).then(
  (res) => {
    console.log("res:", res);
  },
  (err) => {
    console.log("err:", err);//err: reject message
  }
);

```

### 2.3 Promise的对象方法与类方法



#### 2.3.1 对象方法与类方法的区别



类方法：

+ Promise.all()
+ Promise.race()
+ Promise.resolve()
+ Promise.reject()

对象方法:

+ Promise.prototype.then()
+ Promise.prototype.catch()

> 类方法是在Promise类上的静态方法
>
> 而对象方法是在Promise.prototype上定义的
>
> **Object.getOwnPropertyDescriptors(Promise.prototype)** 查看对象方法

```js
const promise = new Promise()
promise.then()//对象方法通过创建对象访问
Promise.all()//类方法直接通过类就可以访问
```

#### 2.3.2 .then 方法

##### thenable

+ `thenable` 是定义`then`方法的对象或函数。

> then 方法中有两个参数 第一个是resolve的返回值，一个是reject的返回值

```js
const promise = new Promise((resolve, reject) => {
  //resolve("hahaha")
   reject(666)
})
promise.then(res => {
  console.log("res1:", res)//hahaha
},err=>{
   console.log("err1:", err)//666
})

```



+ 同一个Promise可以被多次调用then方法
+ 当我们的resolve方法被回调时, 所有的then方法传入的回调函数都会被调用

```js
const promise = new Promise((resolve, reject) => {
  resolve("hahaha")
})
promise.then(res => {
  console.log("res1:", res)//hahaha
})

promise.then(res => {
  console.log("res2:", res)//hahaha
})

promise.then(res => {
  console.log("res3:", res)//hahaha
})

```

+ then方法传入的 "回调函数" 可以有返回值
  + then方法本身也是有返回值的, 它的返回值是Promise

```js
const promise = new Promise((resolve, reject) => {
  resolve("hahaha")
})
promise
  .then((res) => {
    return "aaaaaa";
  })
  .then((res) => {
    console.log("res:", res); //aaaaaa
    return "bbbbbb";
  })
  .then((res) => {
    console.log("res:", res); //bbbbbb
  });
```

+ 返回一个 promise  
  + promise 的状态将会移交给的 promise

```js
promise
  .then((res) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve(111111);
      }, 3000);
    });
  })
  .then((res) => {
    console.log("res:", res); ///111111
  });
```

+ 如果返回的是一个对象, 并且该对象实现了thenable
  + "thenable"是定义`then`方法的对象或函数。
+ promise函数返回时自己调用了一下 `then`函数

```js
promise
  .then((res) => {
    return {
      then: function (resolve, reject) {
        resolve(222222);
      },
    };
  })
  .then((res) => {
    console.log("res:", res); //222222
  });

```



#### 2.3.3 catch 方法

1. 当executor抛出异常时, 会调用错误(拒绝)捕获的回调函数的

```js
const promise = new Promise((resolve, reject) => {
   reject("rejected status")
  // throw new Error("rejected status")
});
//第一个参数为resolve返回值 第二个reject返回值 (也可以捕获异常thorw)
promise.then(undefined, err => {
  console.log("err:", err)//rejected status
})
```

2. 通过catch方法来传入错误(拒绝)捕获的回调函数

```js
const promise = new Promise((resolve, reject) => {
   resolve();
});
promise.catch((err) => {
  console.log("err:", err);
});
promise
  .then((res) => {
    return new Promise((resolve, reject) => {
      //在then中也可以报异常和调用reject
      reject("then rejected status");
    });
    // throw new Error("error message");
  })
  .catch((err) => {
    console.log("err:", err); //then rejected status
  });

```

3. 拒绝捕获的问题在`then` 中

```js
const promise = new Promise((resolve, reject) => {
  // resolve();
  reject("rejected status");
  // throw new Error("rejected status")
});

promise.then(
  (res) => {},
  (err) => {
    console.log("err:", err); //err: rejected status
  }
);
```

```js
const promise = new Promise((resolve, reject) => {
  reject("111111");
  // resolve()
});

promise
  .then((res) => {})
  .then((res) => {
    throw new Error("then error message");
  })
  .catch((err) => {
    console.log("err:", err); //111111因为之前有错误所以捕获到了，不然输出then error message
  });

promise.catch((err) => {});
```

4. catch方法的返回值与链式

```js
const promise = new Promise((resolve, reject) => {
  reject("111111");
});

promise
  .then((res) => {
    console.log("res:", res);
  })
  .catch((err) => {
    console.log("err:", err); //111111
    return "catch return value";
  })
  .then((res) => {
    console.log("res result:", res); //catch return value
  })
  .catch((err) => {
    console.log("err result:", err);
  });

```

#### 2.3.4 finally

+ 一定会执行，完成结束

```js
const promise = new Promise((resolve, reject) => {
  // resolve("resolve message")
  reject("reject message");
});

promise
  .then((res) => {
    console.log("res:", res); //undefined
  })
  .catch((err) => {
    console.log("err:", err); //reject message
  })
  .finally(() => {
    console.log("finally code execute");
  });

```

#### 2.3.5  Promise.resolve 返回值

```js
// 转成Promise对象
function foo() {
  const obj = { name: "why" };
  return new Promise((resolve) => {
    resolve(obj);
  });
}

foo().then((res) => {
  console.log("res:", res); // { name: "why" }
});

// 类方法Promise.resolve
// 1.普通的值
const promise = Promise.resolve({ name: "why" });
// 相当于
const promise2 = new Promise((resolve, reject) => {
  resolve({ name: "why" });
});

// 2.传入Promise
const promise = Promise.resolve(
  new Promise((resolve, reject) => {
    resolve("11111");
  })
);

promise.then((res) => {
  console.log("res:", res); //11111
});

// 3.传入thenable对象

```

#### 2.3.6  Promise.reject 

```js
// const promise = Promise.reject("rejected message")
// 相当于
// const promise2 = new Promsie((resolve, reject) => {
//   reject("rejected message")
// })

// 注意: 无论传入什么值都是一样的
const promise = Promise.reject(new Promise(() => {}));

promise
  .then((res) => {
    console.log("res:", res);
  })
  .catch((err) => {
    console.log("err:", err); // Promise { <pending> }
  });

```

#### 2.3.7  Promise.all

+ **all** 可以将多个**promise**放在一起等待返回
  + **all** 本身也是一个promise
+ all中的多个**promise**如果有一个能变成了**rejected**状态，那么 **all** 整个**promise** 也会进入 **rejected** 状态

```js
// 创建多个Promise
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(11111);
  }, 1000);
});

const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(22222);
  }, 2000);
});

const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(33333);
  }, 3000);
});

// 需求: 所有的Promise都变成fulfilled时, 再拿到结果
// 意外: 在拿到所有结果之前, 有一个promise变成了rejected, 那么整个promise是rejected
Promise.all([p2, p1, p3, "aaaa"])
  .then((res) => {
    console.log(res);
  })
  .catch((err) => {
    console.log("err:", err); ///22222
  });

```

#### 2.3.8 Promise.allSettled

+ **allSettled** 解决 **all** 的一个中断全部中断
  + 但是并没有 **catch** 捕获 ，都在 then 中返回，但返回值中有状态
+ 会返回状态和当前的返回值

```js
// 创建多个Promise
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(11111)
  }, 1000);
})

const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(22222)
  }, 2000);
})

const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(33333)
  }, 3000);
})

// allSettled
Promise.allSettled([p1, p2, p3]).then(res => {
  console.log(res)
}).catch(err => {
  console.log(err)
})
/**
*[
  { status: 'fulfilled', value: 11111 },
  { status: 'rejected', reason: 22222 },//会返回状态和当前的返回值
  { status: 'fulfilled', value: 33333 }
]
*/
```

#### 2.3.9 Promise.race

+ 只要数组中有 `resolve` 或者 `reject` 其中一个返回，直接结束

```js
// 创建多个Promise
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(11111);
  }, 3000);
});

const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(22222); //第一个加载完成返回
    // resolve(11111);
  }, 500);
});

const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(33333);
  }, 1000);
});

// race: 竞技/竞赛
// 只要有一个Promise变成fulfilled状态, 那么就结束
// 意外:
Promise.race([p1, p2, p3])
  .then((res) => {
    console.log("res:", res); //22222
  })
  .catch((err) => {
    console.log("err:", err);
  });

```

#### 2.3.10 Promise.any

+ 多个捕获，只接收 **resolve** 返回值，并且有一个结束就直接回调 ，如果所有的都是 **reject** ，那么最后都执行完会进入 **catch** 返回一个数组，装载着多个 **promise** 的 **reject** 值

```js
// 创建多个Promise
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    // resolve(11111)
    reject(1111);
  }, 1000);
});

const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(22222);
  }, 500);
});

const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    // resolve(33333)
    reject(3333);
  }, 3000);
});

// any方法
Promise.any([p1, p2, p3])
  .then((res) => {
    console.log("res:", res); //1111
  })
  .catch((err) => {
    console.log("err:", err.errors); //[2222, 1111, 3333]
  });

```



### 2.4 实现 promise

#### 2.4.1 手写 promise 结构 (constructor实现)

**需求：**

1. 实现 promise constructor 根据状态返回回调函数

**思路：** 

1. 因为 promise 有状态所以先定义状态常量，并且在执行中判断当前什么状态。
2. 定义 `resolve` 与 `reject` 函数，并在调用 `Promise` 时候传入参数。

```js
// ES6 ES2015
// https://promisesaplus.com/
// 状态
const PROMISE_STATUS_PENDING = "pending"; //加载中
const PROMISE_STATUS_FULFILLED = "fulfilled"; //操作成功
const PROMISE_STATUS_REJECTED = "rejected"; //操作失败

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //判断当前状态
        this.status = PROMISE_STATUS_FULFILLED; //设置当前状态
        this.value = value; //设置正确返回值
        console.log("resolve被调用");
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //判断当前状态
        this.status = PROMISE_STATUS_REJECTED; //设置当前状态
        this.reason = reason; //设置错误返回值
        console.log("reject被调用");
      }
    };

    executor(resolve, reject);
  }
}

const promise = new PZPromise((resolve, reject) => {
  console.log("状态pending");
  resolve(1111);
  reject(2222);
});

```



#### 2.4.2 手写 then 方法

**需求：**

1. 实现 `then` 方法

**思路**

1. 在类中定义一个 `then` 方法，并在方法中转入两个参数方法 `onFulfilled` fulfilled 正确返回 与 `onRejected` rejected 失败返回，在将参数方法赋值给 class 中的值。
2. 执行构造函数 constructor 顺序时，会先执行，但这时 `.then` 还没有执行，所以需要使用 `queueMicrotask` 函数将部分代码创建一个微任务队列中，从而做到先执行 `.then` 在将响应值返回出去。

**缺点**

1. 不可以使用多个 `.then` 。
2. 不可以链式调用。

```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        this.status = PROMISE_STATUS_FULFILLED;
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          this.value = value;
          this.onFulfilled(this.value); //调用正确返回值
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        this.status = PROMISE_STATUS_REJECTED;
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          this.reason = reason;
          this.onRejected(this.reason); //调用错误返回值
        });
      }
    };

    executor(resolve, reject);
  }

  then(onFulfilled, onRejected) {
    this.onFulfilled = onFulfilled;
    this.onRejected = onRejected;
  }
}

const promise = new PZPromise((resolve, reject) => {
  console.log("状态pending");
  // reject(2222)
  resolve(1111);
});

// 调用then方法
promise
  .then(
    (res) => {
      console.log("res1:", res);
      return 1111;
    },
    (err) => {
      console.log("err:", err);
    }
  )
 
//不可以多个then调用
 promise.then(res => {
   console.log("res2:", res)
 }, err => {
   console.log("err2:", err)
 }) .then((res) => {
    //不可以链式调用
    console.log("res3:", res);
  });

```



#### 2.4.3 手写 then 方法优化 1.0

**需求：**

1. 实现 `then` 的多次调用
2. 在确定 `Promise` 状态后直接调用 `.then`

**思路**

1. 在 `then` 方法中将传入的 `onFulfilled` 与 `onRejected` 放到指定数组中，在 构造函数 constructor 对应状态的  `queueMicrotask` 微任务中遍历执行
2. 在 `then` 方法中 判断 状态是否已经结束，如果已经结束那么直接调用 `then` 传入的方法，不走 constructor

**缺点**

1. 不可以链式调用。

```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    executor(resolve, reject);
  }

  then(onFulfilled, onRejected) {
    // 1.如果在then调用的时候, 状态已经确定下来直接执行
    if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
      onFulfilled(this.value);
    }
    if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
      onRejected(this.reason);
    }

    // 2.当前状态等于pedding时候将成功回调和失败的回调放到数组中
    if (this.status === PROMISE_STATUS_PENDING) {
      this.onFulfilledFns.push(onFulfilled);
      this.onRejectedFns.push(onRejected);
    }
  }
}

const promise = new PZPromise((resolve, reject) => {
  console.log("状态pending");
  resolve(1111); // resolved/fulfilled
  reject(2222);
});

// 调用then方法多次调用
promise.then(
  (res) => {
    console.log("res1:", res);
  },
  (err) => {
    console.log("err:", err);
  }
);

promise.then(
  (res) => {
    console.log("res2:", res);
  },
  (err) => {
    console.log("err2:", err);
  }
);

// const promise = new Promise((resolve, reject) => {
//   resolve("aaaaa")
// })

// 在确定Promise状态之后, 再次调用then
setTimeout(() => {
  promise.then(
    (res) => {
      console.log("res3:", res);
    },
    (err) => {
      console.log("err3:", err);
    }
  );
}, 1000);

```

#### 2.4.4 手写 then 方法 优化 2.0

**需求：**

1. 实现 `then` 的链式调用

**思路**

1. 原生 `Promise` then 方法中返回的是一个 `Promise` 对象所以可以链式调用,那么就 `then` 放大中返回 `Promise` 来实现 链式调用
2. 并在 then 中 try catch 捕获异常，区分返回 `resolve` 还是 `reject`



```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

// 工具函数
// 返回resolve || reject
function execFunctionWithCatchError(execFn, value, resolve, reject) {
  try {
    const result = execFn(value);
    resolve(result);
  } catch (err) {
    reject(err);
  }
}

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    try {
      //捕获异常传给reject继续向下走
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    // 返回一个Promise 处理 .then的链式调用问题
    return new PZPromise((resolve, reject) => {
      // 1.如果在then调用的时候, 状态已经确定下来
      if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
        // try {
        //   const value = onFulfilled(this.value)
        //   resolve(value)
        // } catch(err) {
        //   reject(err)
        // }
        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
      }
      if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
        // try {
        //   const reason = onRejected(this.reason)
        //   resolve(reason)
        // } catch(err) {
        //   reject(err)
        // }
        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
      }

      // 2.将成功回调和失败的回调放到数组中
      if (this.status === PROMISE_STATUS_PENDING) {
        this.onFulfilledFns.push(() => {
          // try {
          //   const value = onFulfilled(this.value)
          //   resolve(value)
          // } catch(err) {
          //   reject(err)
          // }
          execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
        });
        this.onRejectedFns.push(() => {
          // try {
          //   const reason = onRejected(this.reason)
          //   resolve(reason)
          // } catch(err) {
          //   reject(err)
          // }
          execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
        });
      }
    });
  }
}

const promise = new PZPromise((resolve, reject) => {
  console.log("状态pending");
  // resolve(1111) // resolved/fulfilled
  reject(2222);
  // throw new Error("executor error message")
});

// 调用then方法多次调用
promise
  .then(
    (res) => {
      console.log("res1:", res);
      return "aaaa";
      // throw new Error("err message")
    },
    (err) => {
      console.log("err1:", err); //2222
      return "bbbbb";
      // throw new Error("err message")
    }
  )
  .then(
    (res) => {
      console.log("res2:", res); //bbbbb
    },
    (err) => {
      console.log("err2:", err);
    }
  );

```



#### 2.4.5 手写promise - catch 方法

**需求：**

1. 实现 `catch` 的错误捕获

**思路**

1. 利用已经实现 `then` 的第二个参数 onRejected 捕获 err
2. 因为 `.then` 是调用的第二个回调参数，所以要处理一下 第二个参数，如果没有值就使用自定义的函数，抛出异常让 `catch` 去捕获

```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

// 工具函数
// 返回resolve || reject
function execFunctionWithCatchError(execFn, value, resolve, reject) {
  try {
    const result = execFn(value);
    resolve(result);
  } catch (err) {
    reject(err);
  }
}

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    try {
      //捕获异常传给reject继续向下走
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    //因为catch是调用的.then
    //而.then抛出错误到下一个err中
    //所以定义抛出异常到第二个promise
    const defaultOnRejected = (err) => {
      throw err;
    };
    onRejected = onRejected || defaultOnRejected;
    // 返回一个Promise 处理 .then的链式调用问题
    return new PZPromise((resolve, reject) => {
      // 1.如果在then调用的时候, 状态已经确定下来
      if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
      }
      if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
      }

      // 2.将成功回调和失败的回调放到数组中
      if (this.status === PROMISE_STATUS_PENDING) {
        if (onFulfilled)
          this.onFulfilledFns.push(() => {
            execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
          });
        if (onRejected)
          this.onRejectedFns.push(() => {
            execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
          });
      }
    });
  }
  // 传给.then的err中
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
}

const promise = new PZPromise((resolve, reject) => {
  console.log("状态pending");
  // resolve(1111) // resolved/fulfilled
  reject(2222);
});

// 调用then方法多次调用
promise
  .then((res) => {
    console.log("res:", res);
  })
  .catch((err) => {
    console.log("err:", err); //'err:' 2222
    throw new Error("err message");
  })
  .then(
    (res) => {
      console.log("res1:", res);
    },
    (err) => {
      console.log("err1:", err); //err1 :err message
    }
  );

```

#### 2.4.5 手写promise - finally 方法

**需求：**

1. 实现 `finally ` 执行完成方法

**思路**

1. 同样调用 `.then` 方法并且在 `then` 两个参数都传入 finally方法

```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

// 工具函数
// 返回resolve || reject
function execFunctionWithCatchError(execFn, value, resolve, reject) {
  try {
    const result = execFn(value);
    resolve(result);
  } catch (err) {
    reject(err);
  }
}

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    try {
      //捕获异常传给reject继续向下走
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    //因为catch是调用的.then
    //而.then抛出错误到下一个err中
    //所以定义抛出异常到第二个promise
    const defaultOnRejected = (err) => {
      throw err;
    };
    onRejected = onRejected || defaultOnRejected;
    // 如果第二个链式调用是catch的话那么是没有onFulfilled的
    // 所以设置一个默认值继续往下走链式then函数
    const defaultOnFulfilled = (value) => {
      return value;
    };
    onFulfilled = onFulfilled || de faultOnFulfilled;
    // 返回一个Promise 处理 .then的链式调用问题
    return new PZPromise((resolve, reject) => {
      // 1.如果在then调用的时候, 状态已经确定下来
      if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
      }
      if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
      }

      // 2.将成功回调和失败的回调放到数组中
      if (this.status === PROMISE_STATUS_PENDING) {
        if (onFulfilled)
          this.onFulfilledFns.push(() => {
            execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
          });
        if (onRejected)
          this.onRejectedFns.push(() => {
            execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
          });
      }
    });
  }
// 传给.then的err中
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }

  finally(onFinally) {
    this.then(
      () => {
        onFinally();
      },
      () => {
        onFinally();
      }
    );
  }
}

const promise = new PZPromise((resolve, reject) => {
  console.log("状态pending");
  resolve(1111); // resolved/fulfilled
  // reject(2222)
});

// 调用then方法多次调用
promise
  .then((res) => {
    console.log("res1:", res);
    return "aaaaa";
  })
  .then((res) => {
    console.log("res2:", res);
  })
  .catch((err) => {
    console.log("err:", err);
  })
  .finally(() => {
    console.log("finally");
  });

```

#### 2.4.6 手写 Promise - resolve与reject 类方法

**需求：**

1. 实现 `resolve`与`reject ` 类方法

**思路**

1. 因为直接要在 class 上访问到的方法，那么一定会使用 `static` 设置为静态方法。
2. 而返回的其实本质还是一个 Promise 所以直接返回自己封装的 Promise 即可

```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

// 工具函数
// 返回resolve || reject
function execFunctionWithCatchError(execFn, value, resolve, reject) {
  try {
    const result = execFn(value);
    resolve(result);
  } catch (err) {
    reject(err);
  }
}

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    try {
      //捕获异常传给reject继续向下走
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    //因为catch是调用的.then
    //而.then抛出错误到下一个err中
    //所以定义抛出异常到第二个promise
    const defaultOnRejected = (err) => {
      throw err;
    };
    onRejected = onRejected || defaultOnRejected;
    // 如果第二个链式调用是catch的话那么是没有onFulfilled的
    // 所以设置一个默认值继续往下走链式then函数
    const defaultOnFulfilled = (value) => {
      return value;
    };
    onFulfilled = onFulfilled || defaultOnFulfilled;
    // 返回一个Promise 处理 .then的链式调用问题
    return new PZPromise((resolve, reject) => {
      // 1.如果在then调用的时候, 状态已经确定下来
      if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
      }
      if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
      }

      // 2.将成功回调和失败的回调放到数组中
      if (this.status === PROMISE_STATUS_PENDING) {
        if (onFulfilled)
          this.onFulfilledFns.push(() => {
            execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
          });
        if (onRejected)
          this.onRejectedFns.push(() => {
            execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
          });
      }
    });
  }
// 传给.then的err中
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }

  finally(onFinally) {
    this.then(
      () => {
        onFinally();
      },
      () => {
        onFinally();
      }
    );
  }
  // 开放静态类方法 resolve 直接返回一个 Promise 即可
  static resolve(value) {
    return new PZPromise((resolve) => resolve(value));
  }
  // 开放静态类方法 reject 直接返回一个 Promise 即可
  static reject(reason) {
    return new PZPromise((resolve, reject) => reject(reason));
  }
}

PZPromise.resolve("Hello World").then((res) => {
  console.log("res:", res);
});

PZPromise.reject("Error Message").catch((err) => {
  console.log("err:", err);
});

```



#### 2.4.7 手写 Promise - all 与 allSettled 类方法

**需求：**

1. 实现类方法 `all` 的等待集合返回，并且如果有一个报错直接返回 `reject` 
2. 实现类方法 `allSettled` 的等待集合返回，只会并且只能返回 `resolve` 在返回值对象数组中标明状态 `fulfilled` 与 `rejected` 

**思路**

1. all 的重点在于什么时候返回 `resolve` 或 `reject` 
   1. 创建一个数组，在then 的正确回调用 判断 `all`  的参数数组 与 定义的数组长度是否相等，如果相等那么就证明都是正确的，返回 `resolve` 
   2. 在`then`的错误中回调用，如果有错误直接将错误 `reject`出去 不等待
2. allSettled 的重点就是定义一个数组，在`then`的正确或者错误中都判断 参数数组 与 定义的数组长度是否相等 ，如果相等都调用 `resolve` 返回出去

```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

// 工具函数
// 返回resolve || reject
function execFunctionWithCatchError(execFn, value, resolve, reject) {
  try {
    const result = execFn(value);
    resolve(result);
  } catch (err) {
    reject(err);
  }
}

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    try {
      //捕获异常传给reject继续向下走
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    //因为catch是调用的.then
    //而.then抛出错误到下一个err中
    //所以定义抛出异常到第二个promise
    const defaultOnRejected = (err) => {
      throw err;
    };
    onRejected = onRejected || defaultOnRejected;
    // 如果第二个链式调用是catch的话那么是没有onFulfilled的
    // 所以设置一个默认值继续往下走链式then函数

    const defaultOnFulfilled = (value) => {
      return value;
    };
    onFulfilled = onFulfilled || defaultOnFulfilled;
    // 返回一个Promise 处理 .then的链式调用问题
    return new PZPromise((resolve, reject) => {
      // 1.如果在then调用的时候, 状态已经确定下来
      if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
      }
      if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
      }

      // 2.将成功回调和失败的回调放到数组中
      if (this.status === PROMISE_STATUS_PENDING) {
        if (onFulfilled)
          this.onFulfilledFns.push(() => {
            execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
          });
        if (onRejected)
          this.onRejectedFns.push(() => {
            execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
          });
      }
    });
  }
  // 传给.then的err中
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }

  finally(onFinally) {
    this.then(
      () => {
        onFinally();
      },
      () => {
        onFinally();
      }
    );
  }
  // 开放静态类方法 resolve 直接返回一个 Promise 即可
  static resolve(value) {
    return new PZPromise((resolve) => resolve(value));
  }
  // 开放静态类方法 reject 直接返回一个 Promise 即可
  static reject(reason) {
    return new PZPromise((resolve, reject) => reject(reason));
  }

  static all(promises) {
    // 问题关键: 什么时候要执行resolve, 什么时候要执行reject
    return new PZPromise((resolve, reject) => {
      const values = [];
      promises.forEach((promise) => {
        promise.then(
          (res) => {
            //向数组中存值
            values.push(res);
            //定义的数组与all传入的数组长度相同，证明循环完毕，执行resolve
            if (values.length === promises.length) {
              resolve(values);
            }
          },
          (err) => {
            reject(err); //只要是有错误直接reject返回出去
          }
        );
      });
    });
  }
  // allSettled 中只会执行 resolve，并且对象数组返回状态值和返回值
  static allSettled(promises) {
    return new PZPromise((resolve) => {
      const results = [];
      promises.forEach((promise) => {
        promise.then(
          (res) => {
            results.push({ status: PROMISE_STATUS_FULFILLED, value: res });
            if (results.length === promises.length) {
              resolve(results);
            }
          },
          (err) => {
            results.push({ status: PROMISE_STATUS_REJECTED, value: err });
            if (results.length === promises.length) {
              resolve(results);
            }
          }
        );
      });
    });
  }
}

const p1 = new Promise((resolve) => {
  setTimeout(() => {
    resolve(1111);
  }, 1000);
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(2222);
  }, 2000);
});
const p3 = new Promise((resolve) => {
  setTimeout(() => {
    resolve(3333);
  }, 3000);
});
// PZPromise.all([p1, p2, p3])
//   .then((res) => {
//     console.log("res", res);
//   })
//   .catch((err) => {
//     console.log("err", err);
//   });

PZPromise.allSettled([p1, p2, p3]).then((res) => {
  console.log(res);
});

```

#### 2.4.7 手写 Promise - race 与 any 类方法（Promise手写完成）

**需求：**

1. race 只要数组中有 `resolve` 或者 `reject` 其中一个返回，直接结束
2. any 多个捕获，只接收 **resolve** 返回值，并且有一个结束就直接回调 ，如果所有的都是 **reject** ，那么最后都执行完会进入 **catch** 返回一个数组，装载着多个 **promise** 的 **reject** 值

**思路:**

1. 实现 `race` 无需考虑其他人，不过是正确还是错误直接回调。
2. 实现 `any` 需要考虑 到如果有正确就直接回调，如果都是错误那么就等待所有结束判断下长度之后返回。

**备注:**

1. 其中使用到了ES12新出的 API `AggregateError` 当多个错误需要包装在一个错误中时，该对象表示一个错误



```js
// ES6 ES2015
// https://promisesaplus.com/
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

// 工具函数
// 返回resolve || reject
function execFunctionWithCatchError(execFn, value, resolve, reject) {
  try {
    const result = execFn(value);
    resolve(result);
  } catch (err) {
    reject(err);
  }
}

class PZPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING; //设置初始值pending
    this.value = undefined; //定义正确变量
    this.reason = undefined; //定义错误变量
    this.onFulfilledFns = []; //定义正确函数数组
    this.onRejectedFns = []; //定义错误函数数组

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_FULFILLED;
          this.value = value;
          this.onFulfilledFns.forEach((fn) => {
            fn(this.value);
          });
        });
      }
    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        //将此段落创建一个微任务并接入到微任务队列中
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_PENDING) return; //预防 resolve、reject都调用
          this.status = PROMISE_STATUS_REJECTED;
          this.reason = reason;
          this.onRejectedFns.forEach((fn) => {
            fn(this.reason);
          });
        });
      }
    };

    try {
      //捕获异常传给reject继续向下走
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    //因为catch是调用的.then
    //而.then抛出错误到下一个err中
    //所以定义抛出异常到第二个promise
    const defaultOnRejected = (err) => {
      throw err;
    };
    onRejected = onRejected || defaultOnRejected;
    // 如果第二个链式调用是catch的话那么是没有onFulfilled的
    // 所以设置一个默认值继续往下走链式then函数

    const defaultOnFulfilled = (value) => {
      return value;
    };
    onFulfilled = onFulfilled || defaultOnFulfilled;
    // 返回一个Promise 处理 .then的链式调用问题
    return new PZPromise((resolve, reject) => {
      // 1.如果在then调用的时候, 状态已经确定下来
      if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {
        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
      }
      if (this.status === PROMISE_STATUS_REJECTED && onRejected) {
        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
      }

      // 2.将成功回调和失败的回调放到数组中
      if (this.status === PROMISE_STATUS_PENDING) {
        if (onFulfilled)
          this.onFulfilledFns.push(() => {
            execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);
          });
        if (onRejected)
          this.onRejectedFns.push(() => {
            execFunctionWithCatchError(onRejected, this.reason, resolve, reject);
          });
      }
    });
  }
  // 传给.then的err中
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }

  finally(onFinally) {
    this.then(
      () => {
        onFinally();
      },
      () => {
        onFinally();
      }
    );
  }
  // 开放静态类方法 resolve 直接返回一个 Promise 即可
  static resolve(value) {
    return new PZPromise((resolve) => resolve(value));
  }
  // 开放静态类方法 reject 直接返回一个 Promise 即可
  static reject(reason) {
    return new PZPromise((resolve, reject) => reject(reason));
  }

  static all(promises) {
    // 问题关键: 什么时候要执行resolve, 什么时候要执行reject
    return new PZPromise((resolve, reject) => {
      const values = [];
      promises.forEach((promise) => {
        promise.then(
          (res) => {
            //向数组中存值
            values.push(res);
            //定义的数组与all传入的数组长度相同，证明循环完毕，执行resolve
            if (values.length === promises.length) {
              resolve(values);
            }
          },
          (err) => {
            reject(err); //只要是有错误直接reject返回出去
          }
        );
      });
    });
  }
  // allSettled 中只会执行 resolve，并且对象数组返回状态值和返回值
  static allSettled(promises) {
    return new PZPromise((resolve) => {
      const results = [];
      promises.forEach((promise) => {
        promise.then(
          (res) => {
            results.push({ status: PROMISE_STATUS_FULFILLED, value: res });
            if (results.length === promises.length) {
              resolve(results);
            }
          },
          (err) => {
            results.push({ status: PROMISE_STATUS_REJECTED, value: err });
            if (results.length === promises.length) {
              resolve(results);
            }
          }
        );
      });
    });
  }

  static race(promises) {
    return new PZPromise((resolve, reject) => {
      promises.forEach((promise) => {
        // promise.then(res => {
        //   resolve(res)
        // }, err => {
        //   reject(err)
        // })
        //只要有结果不管对错直接回调，不需要等其他人
        promise.then(resolve, reject);
      });
    });
  }

  static any(promises) {
    // resolve必须等到有一个成功的结果
    // reject所有的都失败才执行reject
    const reasons = [];
    return new PZPromise((resolve, reject) => {
      promises.forEach((promise) => {
        // 如果有一个正确就直接返回，否则进入err
        promise.then(resolve, (err) => {
          reasons.push(err);
          if (reasons.length === promises.length) {
            //AggregateError 当多个错误​​需要包装在一个错误中时，该对象表示一个错误
            reject(new AggregateError(reasons));
          }
        });
      });
    });
  }
}

const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(1111);
  }, 3000);
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(2222);
  }, 2000);
});
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(3333);
  }, 3000);
});

// PZPromise.race([p1, p2, p3]).then(res => {
//   console.log("res:", res)
// }).catch(err => {
//   console.log("err:", err)
// })

PZPromise.any([p1, p2, p3])
  .then((res) => {
    console.log("res:", res);
  })
  .catch((err) => {
    console.log("err:", err.errors);
  });

```

